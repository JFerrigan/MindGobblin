<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tetris</title>
    <style>
      :root {
        /* Text */
        --ink: #e8edff;
        --muted: #a8b0d9;
        --accent: #6be0ff;
        --panel-text: #cfd6ff;
        --modal-heading: #cfe6ff;
        --modal-body: #c6cff6;
        --btn-text: #ffffff;

        /* Backgrounds */
        --bg: #0f1225;
        --game-bg: #1c3077;
        --mini-bg: #1c3077;
        --menu-btn-bg: #444;
        --menu-btn-bg-hover: #666;
        --hold-btn-bg: #666;
        --modal-overlay: rgba(0,0,0,0.75);

        /* Gradients */
        --btn-gradient: linear-gradient(180deg, #22a6ff, #1180ff);
        --modal-gradient: linear-gradient(180deg, #14172d, #0f1430);

        /* Borders */
        --border-color: #2a3267;

        /* Shadows */
        --game-shadow: 0 15px 45px #0006;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        display: grid;
        place-items: center;
        min-height: 100vh;
        background: var(--bg);
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
        color: var(--ink);
      }

      .container {
        display: flex;
        flex-direction: row;
        gap: 0px;
        padding: 5px;
        align-items: flex-start;
      }

      /* Left (game) */
      .left-panel {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #score-container {
        font-size: 18px;
        margin-bottom: 8px;
        color: var(--muted);
      }
      #score-label { font-weight: 700; margin-right: 6px; color: var(--muted); }
      #score { font: 700 22px/1.2 ui-monospace, Consolas, Menlo, monospace; color: var(--accent); }

      .game-wrapper { width: 240px; max-width: 100%; }

      canvas#game {
        width: 100%;
        height: auto;
        background: var(--game-bg);
        border-radius: 4px;
        border: 1px solid var(--border-color);
        box-shadow: var(--game-shadow);
        display: block;
      }

      /* Right (panel) */
      .right-panel {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 0;
        width: 120px;
      }

      .panel-section {
        width: 100%;
        text-align: center;
        margin-bottom: 12px;
        font-weight: 700;
        color: var(--panel-text);
      }

      .mini-wrapper { width: 96px; margin: 0 auto; }
      .mini-wrapper canvas {
        width: 100%;
        height: auto;
        background: var(--mini-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        display: block;
      }

      button {
        all: unset;
        display: inline-block;
        width: 100%;
        padding: 0.55em 0.6em;
        background: var(--btn-gradient);
        color: var(--btn-text);
        border-radius: 10px;
        font-weight: 700;
        text-align: center;
        cursor: pointer;
        margin-top: 6px;
      }

      /* Hold button */
      button.menu-action { 
        width: 60px;
        height: 15px;
        background: var(--hold-btn-bg); 
      }

      #version { font-size: 11px; color: var(--muted); margin-top: 8px; }

      /* Menu button in right panel above "Next" */
      .menu-btn {
        width: 20px;
        height: 15px;
        font-size: 14px;
        font-weight: bold;
        background: var(--menu-btn-bg);
        color: var(--btn-text);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        align-self: flex-end; /* push to right edge of panel */
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 2px;
        margin: 0;
      }
      .menu-btn:hover { background: var(--menu-btn-bg-hover); }

      /* Modal (menu & controls) */
      .modal {
        position: fixed;
        inset: 0;
        background: var(--modal-overlay);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1200;
      }

      .modal-content {
        background: var(--modal-gradient);
        border: 1px solid var(--border-color);
        padding: 18px;
        border-radius: 12px;
        width: 92%;
        max-width: 420px;
        color: var(--ink);
        text-align: center;
      }

      .modal-content > div {
        display: flex;
        flex-direction: column; /* stack children vertically */
        gap: 8px;               /* optional spacing between buttons */
        align-items: center;    /* horizontal centering */
      }

      .modal-content h2 {
        margin: 0 0 12px;
        font-size: 18px;
        color: var(--modal-heading);
      }
      .modal-content p, 
      .modal-content li { color: var(--modal-body); text-align: left; }

      .modal-content button {
        width: 80px;
        padding: 8px 12px;
        margin: 8px 6px 0;
      }

      /* small screen tweaks */
      @media (max-width: 420px) {
        .right-panel { width: 110px; }
        .mini-wrapper { width: 80px; }
        .game-wrapper { width: 220px; }
        .menu-btn {
          width: 18px;
          height: 18px;
          font-size: 12px;
        }
      }
      
      /* Left-align text for level and lines display */
      .right-panel .panel-section:nth-of-type(3),
      .right-panel .panel-section:nth-of-type(4) {
        text-align: left;
        padding-left: 10px;
      }

      #playerNameField {
        text-align: center;
      }

      #scoreTable {
        width: 70%;
        border-collapse: collapse;
        margin: 8px auto;
        font-size: 14px;
      }

      #scoreTable th,
      #scoreTable td {
        padding: 6px 10px;
        text-align: left;
        border-bottom: 1px solid var(--muted);
      }

      #scoreTable th {
        color: var(--accent);
        font-weight: 700;
        text-align: center;
      }

      #scoreTable td:last-child {
        text-align: right; /* Align scores to the right */
      }

      #scoreTable tr.highlight {
        font-weight: bold;
        color: orange;
      }


    </style>
  </head>

  <body>
    <div class="container">
      <!-- Left side: Score + Game -->
      <div class="left-panel">
        <div id="score-container">
          <span id="score-label">Score:</span><span id="score">0</span>
        </div>
        <div class="game-wrapper">
          <canvas id="game" width="240" height="480" aria-label="Tetris board" role="img"></canvas>
        </div>
      </div>

      <!-- Right side panel -->
      <div class="right-panel" aria-hidden="false">
        <button id="menuBtn" class="menu-btn" aria-label="Menu">â€¦</button>

        <div class="panel-section">
          <div>Next</div>
          <div class="mini-wrapper">
            <canvas id="next" width="96" height="96"></canvas>
          </div>
        </div>

        <div class="panel-section">
          <div>Hold</div>
          <div class="mini-wrapper">
            <canvas id="hold" width="96" height="96"></canvas>
          </div>
          <button id="holdBtn" class="menu-action">Hold</button>
        </div>

        <div class="panel-section">LVL: <span id="level">1</span></div>
        <div class="panel-section">Lines: <span id="lines">0</span></div>

        <div id="version">v1.03</div>
      </div>
    </div>

    <!-- Menu Modal -->
    <div id="menuModal" class="modal" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal-content" id="menuContent" style="display: none;">
        <h2>Menu</h2>
        <h2>-- Game Paused --</h2>
        <div>
          <button id="menuStartBtn">Start</button>
          <button id="menuScoreboardBtn">Scoreboard</button>
          <button id="menuChangeNameBtn">Change Name</button>
          <button id="menuControlsBtn">Controls</button>
          <button id="menuCloseBtn" class="menu-action">Close</button>
        </div>
      </div>

      <div class="modal-content" id="scoreboard" style="display: none;">
        <h2>Scoreboard</h2>
        <table id="scoreTable">
          <thead>
            <tr>
              <th>#</th>
              <th>Player</th>
              <th>Score</th>
            </tr>
          </thead>
          <tbody id="scoreRows"><!-- Score rows will go here --></tbody>
        </table>
        <div style="margin-top:12px;">
          <button id="scoreboardBackBtn" class="menu-action">Back</button>
        </div>
      </div>


      <div class="modal-content" id="controlsContent" style="display: none;">
        <h2>Controls</h2>
        <h3>Keyboard</h3>
        <ul>
          <li>Arrow Left/Right: Move piece</li>
          <li>Arrow Down: Soft drop</li>
          <li>Space: Hard drop</li>
          <li>Up Arrow: Rotate right</li>
          <li>Z: Rotate left</li>
          <li>R: Start/Restart</li>
          <li>P: Open menu</li>
          <li>C: Hold</li>
        </ul>
        <h3>Touch</h3>
        <ul>
          <li>Swipe Left/Right: Move piece</li>
          <li>Swipe Down (slow + hold): Soft drop</li>
          <li>Swipe Down (quick flick): Hard drop</li>
          <li>Tap: Rotate</li>
        </ul>
        <div style="margin-top:12px;">
          <button id="controlsBackBtn" class="menu-action">Back</button>
        </div>
      </div>

      <!-- Player Name Input -->
      <div class="modal-content" id="playerNameInput" style="display: none;">
        <h2>Player Name:</h2>
        <input 
          type="text" 
          id="playerNameField" 
          maxlength="20" 
          value="Guest" 
          style="width: 80%; padding: 6px; font-size: 16px; border-radius: 6px; border: 1px solid #2a3267; background: var(--panel); color: var(--ink);"
        />
        <div style="margin-top: 12px;">
          <button id="playerNameConfirmBtn">OK</button>
        </div>
      </div>
    </div>

    <script>
      (function () {
        // --- Constants / DOM
        const COLS = 10, ROWS = 20, SIZE = 24;
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const nextCtx = document.getElementById("next").getContext("2d");
        const holdCtx = document.getElementById("hold").getContext("2d");
        const comboInterval = 2000; // in ms

        // Tetromino definitions (same as before)
        const P = {
          I: { c: "#22e6ff", r: [
            [
              [0,0,0,0],
              [1,1,1,1],
              [0,0,0,0],
              [0,0,0,0]
            ],
            [
              [0,0,1,0],
              [0,0,1,0],
              [0,0,1,0],
              [0,0,1,0]
            ],
            [
              [0,0,0,0],
              [0,0,0,0],
              [1,1,1,1],
              [0,0,0,0]
            ],
            [
              [0,1,0,0],
              [0,1,0,0],
              [0,1,0,0],
              [0,1,0,0]
            ]
          ]},
          J: { c: "#5cb6ff", r: [
            [
              [1,0,0],
              [1,1,1],
              [0,0,0]
            ],
            [
              [0,1,1],
              [0,1,0],
              [0,1,0]
            ],
            [
              [0,0,0],
              [1,1,1],
              [0,0,1]
            ],
            [
              [0,1,0],
              [0,1,0],
              [1,1,0]
            ]
          ]},
          L: { c: "#ffc35c", r: [
            [
              [0,0,1],
              [1,1,1],
              [0,0,0]
            ],
            [
              [0,1,0],
              [0,1,0],
              [0,1,1]
            ],
            [
              [0,0,0],
              [1,1,1],
              [1,0,0]
            ],
            [
              [1,1,0],
              [0,1,0],
              [0,1,0]
            ]
          ]},
          O: { c: "#ffe66b", r: [
            [
              [1,1],
              [1,1]
            ]
          ]},
          S: { c: "#8aff6b", r: [
            [
              [0,1,1],
              [1,1,0],
              [0,0,0]
            ],
            [
              [0,1,0],
              [0,1,1],
              [0,0,1]
            ]
          ]},
          T: { c: "#b28bff", r: [
            [
              [0,1,0],
              [1,1,1],
              [0,0,0]
            ],
            [
              [0,1,0],
              [0,1,1],
              [0,1,0]
            ],
            [
              [0,0,0],
              [1,1,1],
              [0,1,0]
            ],
            [
              [0,1,0],
              [1,1,0],
              [0,1,0]
            ]
          ]},
          Z: { c: "#ff6b6b", r: [
            [
              [1,1,0],
              [0,1,1],
              [0,0,0]
            ],
            [
              [0,0,1],
              [0,1,1],
              [0,1,0]
            ]
          ]}
        };
        const TYPES = Object.keys(P);

        // --- State
        let grid, current, nextType = null, bag = [], held = null, canHold = true;
        let dropInterval = 900, dropCounter = 0, lastTime = 0;
        let paused = true, over = false, started = false;
        let score = 0, lines = 0, level = 1;
        let lastComboTime = 0, comboCount = 0;
        let clearing = null;
        let playerName = "Guest";
        let initialGameLoad = true;
        let preMenuPaused = null;
        let isTextEntry = false;
        let isGameOverScoreboard = false;
        let playerPlacement = null;
        let isScoreboardOpen = false;

        // UI refs
        const $score = document.getElementById("score");
        const $lines = document.getElementById("lines");
        const $level = document.getElementById("level");
        const $menuStartBtn = document.getElementById("menuStartBtn");
        const scoreboard = document.getElementById("scoreboard");
        const scoreRows = document.getElementById("scoreRows");
        const playerNameInput = document.getElementById("playerNameInput");
        const playerNameField = document.getElementById("playerNameField");
        const playerNameConfirmBtn = document.getElementById("playerNameConfirmBtn");

        // Scoreboard
        // Submit score
        async function submitScore(player, points) {
          const res = await fetch('/api/tetrisscores', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ player, points })
          });

          const saved = await res.json(); // { Id, Player, Points }
          playerPlacement = saved.id;
        }
        // Fetch top10 scores
        async function loadScores() {
          const res = await fetch('/api/tetrisscores');
          const scores = await res.json();

          scoreRows.innerHTML = scores
            .map((s, i) => `<tr>
                              <td>${i + 1}</td>
                              <td>${s.player}</td>
                              <td>${s.points}</td>
                            </tr>`)
            .join("");
        }
        // Fetch top10 scores with player highlight
        async function loadScoreshl(playerId) {
          const res = await fetch(`/api/tetrisscoreshl?playerId=${playerId}`);
          const data = await res.json();

          let rows = "";

          data.top.forEach(s => {
            const highlight = (s.id === playerId) ? "highlight" : "";
            rows += `<tr class="${highlight}">
                      <td>${s.placement}</td>
                      <td>${s.player}</td>
                      <td>${s.points}</td>
                    </tr>`;
          });

          if (data.player && data.player.placement > 10) {
            rows += `<tr><td></td><td>...</td><td></td></tr>`;
            rows += `<tr class="highlight">
                      <td>${data.player.placement}</td>
                      <td>${data.player.player}</td>
                      <td>${data.player.points}</td>
                    </tr>`;
          }

          scoreRows.innerHTML = rows;
        }

        // Helpers
        const newGrid = () => Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        const matFor = (p) => {
          const rs = P[p.type].r;
          return rs[p.rot % rs.length];
        };
        function randBag() {
          const a = TYPES.slice();
          for (let i = a.length - 1; i > 0; i--) {
            const j = (Math.random() * (i + 1)) | 0;
            [a[i], a[j]] = [a[j], a[i]];
          }
          return a;
        }
        function take() {
          if (!bag.length) bag = randBag();
          return bag.pop();
        }

        function drawPreview(c2d, type) {
          // draw into 96x96 preview canvases
          const size = 96;
          c2d.clearRect(0, 0, size, size);
          const m = P[type].r[0], col = P[type].c, cell = 18;
          const w = m[0].length * cell, h = m.length * cell;
          const ox = (size - w) / 2, oy = (size - h) / 2;
          c2d.fillStyle = col;
          for (let y = 0; y < m.length; y++)
            for (let x = 0; x < m[0].length; x++)
              if (m[y][x]) c2d.fillRect(ox + x * cell, oy + y * cell, cell - 1, cell - 1);
        }

        function collision(board, p) {
          const m = matFor(p);
          for (let y = 0; y < m.length; y++) {
            for (let x = 0; x < m[y].length; x++) {
              if (!m[y][x]) continue;
              const nx = p.x + x, ny = p.y + y;
              if (nx < 0 || nx >= COLS) return true;
              if (ny >= ROWS) return true;
              if (ny >= 0 && board[ny][nx]) return true;
            }
          }
          return false;
        }

        function merge(board, p) {
          const m = matFor(p), col = P[p.type].c;
          for (let y = 0; y < m.length; y++)
            for (let x = 0; x < m[y].length; x++)
              if (m[y][x]) {
                const nx = p.x + x, ny = p.y + y;
                if (ny >= 0) board[ny][nx] = col;
              }
        }

        function getFullLines() {
          const rows = [];
          for (let y = ROWS - 1; y >= 0; y--) if (grid[y].every((v) => v)) rows.push(y);
          return rows;
        }

        function startClear(rows) {
          clearing = { rows: rows.slice(), elapsed: 0, duration: 350 };
        }

        function finalizeClear() {
          const rows = clearing.rows.slice().sort((a, b) => b - a);
          const n = rows.length;
          for (const y of rows) grid.splice(y, 1);
          for (let i = 0; i < n; i++) grid.unshift(Array(COLS).fill(0));
          if (n) {
            const pts = [0,40,100,300,1200][n] * level;
            const now = performance.now();
            const timeSinceCombo = now - lastComboTime;
            lastComboTime = now;
            if (timeSinceCombo < comboInterval) comboCount++; else comboCount = 0;
            const comboPtsBonus = Math.round(pts * comboCount);
            score += pts + comboPtsBonus;
            lines += n;
            level = 1 + ((lines / 10) | 0);
            dropInterval = Math.max(80, 900 - (level - 1) * 80);
            updateHUD();
          }
          clearing = null;
        }

        function spawn() {
          if (!nextType) nextType = take();
          const t = nextType;
          nextType = take();
          drawPreview(nextCtx, nextType);
          setCurrent(t)
          if (collision(grid, current)) gameOver();
          canHold = true;
        }

        function setCurrent(t) {
          const mat = P[t].r[0];
          current = { 
            type: t, 
            rot: 0, 
            x: ((COLS / 2) | 0) - ((mat[0].length / 2) | 0), 
            y: -1,
            drawX: 0, targetX: 0,
            drawY: 0, targetY: 0
          };
          current.drawX = current.x * SIZE;
          current.targetX = current.x * SIZE;
          current.drawY = current.y * SIZE;
          current.targetY = current.y * SIZE;
        }

        function softDrop() {
          if (!noGameInputPeriod()) {
            current.y++;
            if (collision(grid, current)) {
              current.y--;
              lockPiece();
            } else {
              current.targetY = current.y * SIZE;
            }
          }
        }

        function hardDrop() {
          if (!noGameInputPeriod()) {
            let fall = 0;
            while (true) {
              current.y++;
              if (collision(grid, current)) {
                current.y--;
                break;
              }
              fall++;
            }
            score += fall * 2;
            current.targetY = current.y * SIZE; // sync to new final position
            lockPiece();
          }
        }


        function move(dx) {
          current.x += dx;
          if (collision(grid, current)) {
            current.x -= dx;
          } else {
            // update target in pixels (SIZE = 24 px per cell)
            current.targetX = current.x * SIZE;
          }
        }

        function rotate() {
          if (!noGameInputPeriod()) {
            const oldRot = current.rot;
            current.rot = (current.rot + 1) % 4;

            if (collision(grid, current)) {
              // Try to push piece back inside bounds
              let kicked = false;
              for (let offset of [-1, 1, -2, 2]) {
                current.x += offset;
                if (!collision(grid, current)) {
                  kicked = true;
                  break;
                }
                current.x -= offset;
              }
              if (!kicked) {
                // rotation not possible, revert
                current.rot = oldRot;
              }
            }
            current.targetX = current.x * SIZE;
            current.targetY = current.y * SIZE;
          }
        }

        function rotateCounter() {
          const len = P[current.type].r.length;
          const prevR = current.rot, prevX = current.x, prevY = current.y;
          current.rot = (current.rot + len - 1) % len;
          const kicks = [0,1,-1,2,-2];
          for (const k of kicks) {
            current.x = prevX + k; current.y = prevY;
            if (!collision(grid, current)) return;
          }
          current.rot = prevR; current.x = prevX; current.y = prevY;
        }

        function hold() {
          if (!canHold) return;
          if (held == null) {
            held = current.type;
            drawPreview(holdCtx, held);
            spawn();
          } else {
            const t = held;
            held = current.type;
            drawPreview(holdCtx, held);
            setCurrent(t)
            if (collision(grid, current)) gameOver();
          }
          canHold = false;
        }

        function lockPiece() {
          merge(grid, current);
          current = null;
          const rows = getFullLines();
          if (rows.length) startClear(rows);
          spawn();
        }

        function drawCell(cx, cy, color, alpha = 1) {
          const x = cx * SIZE, y = cy * SIZE;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = color;
          ctx.fillRect(x, y, SIZE - 1, SIZE - 1);
          ctx.globalAlpha = 1;
        }

        function overlay(text) {
          ctx.save();
          ctx.fillStyle = "#0009";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#e8ecff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = "700 18px ui-monospace,Consolas";
          const a = text.split("\n");
          a.forEach((l, i) => ctx.fillText(l, canvas.width / 2, canvas.height / 2 + i * 22));
          ctx.restore();
        }

        function draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let y = 0; y < ROWS; y++)
            for (let x = 0; x < COLS; x++)
              if (grid[y][x]) drawCell(x, y, grid[y][x]);

          if (current) {
            let gy = current.y;
            const ghost = { ...current };
            while (true) {
              gy++; ghost.y = gy;
              if (collision(grid, ghost)) { gy--; break; }
            }
            const col = P[current.type].c, m = matFor(current);
            // Ghost piece
            for (let y = 0; y < m.length; y++)
              for (let x = 0; x < m[y].length; x++)
                if (m[y][x]) drawCell(current.x + x, gy + y, col, 0.25);
            // Real piece
            for (let y = 0; y < m.length; y++) {
              for (let x = 0; x < m[y].length; x++) {
                if (m[y][x]) {
                  const px = current.drawX + x * SIZE;
                  const py = current.drawY + y * SIZE;
                  ctx.fillStyle = col;
                  ctx.fillRect(px, py, SIZE - 1, SIZE - 1);
                }
              }
            }
          }

          if (clearing) {
            const on = ((clearing.elapsed / 100) | 0) % 2 === 0;
            if (on) {
              ctx.fillStyle = "rgba(255,255,255,0.85)";
              for (const y of clearing.rows) ctx.fillRect(0, y * SIZE, canvas.width, SIZE);
            }
          }

          if (!started) { overlay("Press HERE to Start"); return; }
          if (paused && !over) overlay("Paused");
          if (over) overlay("Game Over\n\nPress HERE to\nTry Again");
        }

        function updateHUD() {
          $score.textContent = score;
          $lines.textContent = lines;
          $level.textContent = level;
        }

        function start() {
          grid = newGrid();
          score = 0; lines = 0; level = 1;
          lastComboTime = 0; comboCount = 0;
          dropInterval = 900;
          started = true; over = false; paused = false; clearing = null;
          bag = []; nextType = null; held = null; canHold = true;
          holdCtx.clearRect(0,0,96,96); nextCtx.clearRect(0,0,96,96);
          if (started) $menuStartBtn.textContent = "Restart";
          spawn(); updateHUD();
        }

        function pauseToggle() {
          if (!over && started) paused = !paused;
        }

        function gameOver() {
          updateHUD();
          over = true; 
          paused = true;
          submitScore(playerName, score)
          setTimeout(gameOverScoreboard, 500); // small delay to give score submission time to run before fetching scoreboard
        }

        function gameOverScoreboard() {
          loadScoreshl(playerPlacement);
          isGameOverScoreboard = true;
          preMenuPaused = paused;
          paused = true;
          menuModal.style.display = "flex";
          menuModal.setAttribute("aria-hidden", "false");
          scoreboard.style.display = "block";
          playerNameInput.style.display = "none";
          menuContent.style.display = "none";
          controlsContent.style.display = "none";
          isScoreboardOpen = true;
        }

        function loop(t = 0) {
          const dt = t - lastTime; lastTime = t;
          // smoothing factor (higher = snappier)
          const SMOOTH_SPEED = 0.25;

          // Horizontal auto-repeat
          const now = t;
          if (hdir === -1 && keys.left.held) {
            if (now >= keys.left.next) { if (current) move(-1); keys.left.next = now + ARR; }
          } else if (hdir === 1 && keys.right.held) {
            if (now >= keys.right.next) { if (current) move(1); keys.right.next = now + ARR; }
          }

          // Soft-drop auto-repeat
          if (keys.down.held && now >= keys.down.next) {
            if (!clearing) softDrop();
            keys.down.next = now + SDARR;
          }

          if (clearing) {
            clearing.elapsed += dt;
            if (clearing.elapsed >= clearing.duration) finalizeClear();
          } else if (!paused && !over) {
            dropCounter += dt;
            if (dropCounter > dropInterval) { dropCounter = 0; softDrop(); }
          }

          if (current) {
            current.drawX += (current.targetX - current.drawX) * SMOOTH_SPEED;
            current.drawY += (current.targetY - current.drawY) * SMOOTH_SPEED;
          }
          draw();
          requestAnimationFrame(loop);
        }

        function noGameInputPeriod() {
          return (paused || clearing || over);
        }

        function sanitizePlayerName(name) {
          // Trim spaces
          let trimmed = name.trim();

          // If empty, default to Guest
          if (!trimmed) return "Guest";

          // Remove potentially problematic characters (quotes, semicolons, etc.)
          return trimmed.replace(/['";]/g, "") || "Guest";
        }

        // Input constants
        const DAS = 100, ARR = 60;
        const SDR = 0, SDARR = 60;

        // Key state
        let hdir = 0;
        const keys = { left: { held: false, next: 0 }, right: { held: false, next: 0 }, down: { held: false, next: 0 } };

        // --- Keyboard Inputs
        window.addEventListener("keydown", (e) => {
          if (isTextEntry) return;
          const k = e.key;
          if (["ArrowLeft","ArrowRight","ArrowDown","ArrowUp"," "].includes(k)) e.preventDefault();
          if (k === "r" || k === "R") {
            if (preMenuPaused !== null) return;
            start();
            return;
          }
          // NOTE: 'P' no longer pauses here; menu toggle handled separately
          if (noGameInputPeriod()) return;

          switch (k) {
            case "ArrowLeft":
              if (!keys.left.held) { keys.left.held = true; hdir = -1; move(-1); keys.left.next = performance.now() + Math.max(DAS, ARR); }
              break;
            case "ArrowRight":
              if (!keys.right.held) { keys.right.held = true; hdir = 1; move(1); keys.right.next = performance.now() + Math.max(DAS, ARR); }
              break;
            case "ArrowDown":
              if (!keys.down.held) { keys.down.held = true; softDrop(); keys.down.next = performance.now() + Math.max(SDR, SDARR); }
              break;
            case "ArrowUp":
              rotate(); break;
            case "z": case "Z":
              rotateCounter(); break;
            case " ":
              hardDrop(); break;
            case "c": case "C":
              hold(); break;
          }
        }, { passive: false });

        window.addEventListener("keyup", (e) => {
          if (isTextEntry) return;
          if (e.key === "ArrowLeft") { keys.left.held = false; if (hdir === -1) hdir = keys.right.held ? 1 : 0; }
          else if (e.key === "ArrowRight") { keys.right.held = false; if (hdir === 1) hdir = keys.left.held ? -1 : 0; }
          else if (e.key === "ArrowDown") { keys.down.held = false; }
        });

        // Toggle menu with 'P' key (separate listener so it always works)
        // Close scoreboared, if open, with Enter
        window.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            if (isTextEntry) setPlayerName();
            if (isScoreboardOpen) closeScoreboard();
          }
          if (isTextEntry) return;
          if (e.key === "p" || e.key === "P") {
            e.preventDefault();
            toggleMenu();
          }
        }, { passive: false });

        // --- Touch inputs (refined)
        const gameCanvas = document.getElementById("game");
        let touchStartX = 0, touchStartY = 0, touchStartTime = 0, lastMoveX = 0;
        let softDropInterval = null;
        const swipeThreshold = 30, fastSwipeTime = 200, tapThreshold = 10, tapTime = 200, moveStep = 20, softDropRate = 50;

        gameCanvas.addEventListener("touchstart", (e) => {
          if (e.touches.length !== 1) return;
          const rect = gameCanvas.getBoundingClientRect();
          const x = e.touches[0].clientX, y = e.touches[0].clientY;
          if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return;
          e.preventDefault();
          touchStartX = x; touchStartY = y; touchStartTime = performance.now(); lastMoveX = x;
        }, { passive: false });

        gameCanvas.addEventListener("touchmove", (e) => {
          if (e.touches.length !== 1) return;
          const rect = gameCanvas.getBoundingClientRect();
          const x = e.touches[0].clientX, y = e.touches[0].clientY;
          if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return;
          e.preventDefault();

          const dx = x - lastMoveX;
          const dy = y - touchStartY;
          const dt = performance.now() - touchStartTime;

          // --- Horizontal drag movement (independent of vertical) ---
          if (Math.abs(dx) >= moveStep) {
            if (dx > 0) move(1); else move(-1);
            lastMoveX = x;
          }

          // --- Slow downward hold => soft drop ---
          if (dy > swipeThreshold && dt >= fastSwipeTime && !softDropInterval) {
            softDrop(); // immediate
            softDropInterval = setInterval(() => {
              if (!paused && !clearing && current) softDrop();
            }, softDropRate);
          }
        }, { passive: false });

        gameCanvas.addEventListener("touchend", (e) => {
          const x = e.changedTouches[0].clientX, y = e.changedTouches[0].clientY;
          e.preventDefault();
          clearInterval(softDropInterval); softDropInterval = null;

          const dx = x - touchStartX, dy = y - touchStartY, dt = performance.now() - touchStartTime;
          const absDx = Math.abs(dx), absDy = Math.abs(dy);

          if (absDx < tapThreshold && absDy < tapThreshold && dt < tapTime) {
            if (over || !started) { start(); return; }
            rotate();
          } else if (dy > swipeThreshold && dt < fastSwipeTime) {
            hardDrop();
          }
        }, { passive: false });

        // --- Menu
        const menuBtn = document.getElementById("menuBtn");
        const menuModal = document.getElementById("menuModal");
        const menuContent = document.getElementById("menuContent");
        const menuScoreboardBtn = document.getElementById("menuScoreboardBtn");
        const scoreboardBackBtn = document.getElementById("scoreboardBackBtn");
        const controlsContent = document.getElementById("controlsContent");
        const menuControlsBtn = document.getElementById("menuControlsBtn");
        const menuCloseBtn = document.getElementById("menuCloseBtn");
        const controlsBackBtn = document.getElementById("controlsBackBtn");
        const gameBoard = document.getElementById("game");
        const menuChangeNameBtn = document.getElementById("menuChangeNameBtn");


        function openMenu() {
          preMenuPaused = paused;
          paused = true;
          menuModal.style.display = "flex";
          menuModal.setAttribute("aria-hidden", "false");
          menuContent.style.display = "block";
          controlsContent.style.display = "none";
          scoreboard.style.display = "none";
          playerNameInput.style.display = "none";
        }

        function closeMenu() {
          isTextEntry = false;
          menuModal.style.display = "none";
          menuModal.setAttribute("aria-hidden", "true");
          // restore only if preMenuPaused was set
          if (preMenuPaused !== null) { paused = preMenuPaused; preMenuPaused = null; }
        }

        function toggleMenu() {
          if (menuModal.style.display === "flex") closeMenu(); else openMenu();
        }

        function setPlayerName() {
          playerName = sanitizePlayerName(playerNameField.value);
          playerNameInput.style.display = "none";
          if (initialGameLoad) {
            closeMenu()
            initialGameLoad = false;
          } else {
            menuContent.style.display = "block";
          }
          isTextEntry = false;
        }

        function closeScoreboard() {
          scoreboard.style.display = "none";
          if (isGameOverScoreboard) {
            closeMenu()
            isGameOverScoreboard = false;
          } else {
            menuContent.style.display = "block";
          }
          isScoreboardOpen = false;
        }

        // Menu actions
        menuBtn.addEventListener("click", openMenu);
        menuModal.addEventListener("click", (e) => { if (e.target === menuModal) closeMenu(); });

        menuStartBtn.addEventListener("click", () => {
          // starting a new game: just start and hide menu (do not restore paused)
          start();
          menuModal.style.display = "none";
          menuModal.setAttribute("aria-hidden", "true");
          preMenuPaused = null;
        });

        menuScoreboardBtn.addEventListener("click", () => {
          isScoreboardOpen = true;
          loadScores();
          menuContent.style.display = "none";
          scoreboard.style.display = "block";
        });

        scoreboardBackBtn.addEventListener("click", () => {
          closeScoreboard();
        });

        menuControlsBtn.addEventListener("click", () => {
          menuContent.style.display = "none";
          controlsContent.style.display = "block";
        });

        menuCloseBtn.addEventListener("click", () => closeMenu());

        controlsBackBtn.addEventListener("click", () => {
          controlsContent.style.display = "none";
          menuContent.style.display = "block";
        });

        menuChangeNameBtn.addEventListener("click", () => {
          isTextEntry = true;
          playerNameInput.style.display = "block";
          menuContent.style.display = "none";
        });

        playerNameConfirmBtn.addEventListener("click", () => {
          setPlayerName();
        });

        // Hook up hold button
        document.getElementById("holdBtn").addEventListener("click", () => hold());

        // For starting game by clicking on game grid
        gameBoard.addEventListener("click", () => {
          if (over || !started) start();
        });

        window.addEventListener("load", () => {
          isTextEntry = true;
          menuModal.style.display = "flex";
          menuModal.setAttribute("aria-hidden", "false");
          playerNameInput.style.display = "block";
          menuContent.style.display = "none";
          controlsContent.style.display = "none";
          scoreboard.style.display = "none";
        });

        // --- Boot
        grid = newGrid();
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
