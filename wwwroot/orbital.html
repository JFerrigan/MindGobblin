<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Orbital Simulation – The Helion System</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    color: #fff;
  }
  #game {
    display: block;
    background: radial-gradient(circle at 50% 130%, #001018, #000000 65%, #02020a);
  }
  #overlay {
    position: fixed;
    top: 8px;
    left: 8px;
    font-size: 14px;
    text-shadow: 0 0 4px #000;
    pointer-events: none;
    white-space: pre;
  }
  #help {
    position: fixed;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    text-shadow: 0 0 4px #000;
    text-align: center;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>
<div id="help">
  Controls: ← → rotate · ↑ thrust / takeoff · SPACE stage · R reset · [ / ] time warp · - / = zoom · F follow/free<br>
  Mouse wheel zooms · Drag to pan (free cam) · Dashed path = coast-only trajectory under moving Helion + planet gravity.<br>
  Transfer planner: 1–8 select target planet · P plan Helion-centered Hohmann (inner → outer only) · O toggle Sun orbit overlay

</div>

<script>
(function () {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const SAFE_COORD = 1_000_000;
  const SAFE_ORBIT_RADIUS_PX = 20000;

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  // --- Time warp ---------------------------------------------------------
  let timeScale = 1;
  const MIN_WARP = 0.1;
  const MAX_WARP = 50000;   // allow very high warp

  // --- Camera: zoom, pan, follow ----------------------------------------
  let cameraZoom = 100000;
  const MIN_ZOOM = 0.25;
  const MAX_ZOOM = 100000;

  let cameraX = 0;
  let cameraY = 0;
  let cameraFollow = true;

  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartCamX = 0;
  let dragStartCamY = 0;

    // --- Transfer planner state -------------------------------------------
  let transferTargetIndex = 3;  // default target
  let transferPlan = null;
  let showSunOrbit = true;


  function normalizeAngle(a) {
    const twoPi = Math.PI * 2;
    a = a % twoPi;
    if (a < 0) a += twoPi;
    return a;
  }

  function smallestAngleDiff(target, current) {
    const t = normalizeAngle(target);
    const c = normalizeAngle(current);
    let d = t - c;
    if (d > Math.PI) d -= 2 * Math.PI;
    if (d < -Math.PI) d += 2 * Math.PI;
    return d;
  }

  function setTransferTarget(index) {
    if (index <= 0 || index >= BODIES.length) return;
    transferTargetIndex = index;
    transferPlan = null;
    if (state) {
      state.message = "Transfer target: " + BODIES[index].name;
    }
  }

  // --- Celestial bodies: Helion + orbiting planets ----------------------
  // Scale orbital radii up to get a larger "solar system".
  const ORBIT_SCALE = 50;

    // Ignore gravitational contributions that are tiny compared to the strongest pull
  const GRAV_PERTURB_THRESHOLD = 0.03; // 3% of dominant acceleration


  const BODIES = [
    {
      // Central star
      name: "Helion",
      x: 0,
      y: 0,
      radius: 1200,
      mu: 4.0176e7,      // high for nice orbital speeds
      atmosphere: 0,
      colors: { inner: "#fff7b3", mid: "#ffcc33", outer: "#d47a1a" }
    },
    {
      // Homeworld – Earth-like (~1 g)
      name: "Astraia",
      orbitalRadius: 15000 * ORBIT_SCALE,
      angle: 0,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 600,
      mu: 3531.6,        // g ≈ 9.81 m/s²
      atmosphere: 40,
      colors: { inner: "#08384f", mid: "#0a5b32", outer: "#021016" }
    },
    {
      // Rocky twilight world (~0.38 g, Mars-ish)
      name: "Nyxos",
      orbitalRadius: 21000 * ORBIT_SCALE,
      angle: 1.4,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 300,
      mu: 333.9,
      atmosphere: 0,
      colors: { inner: "#30213b", mid: "#5b3e7a", outer: "#150d1f" }
    },
    {
      // Ocean world (slightly > 1 g)
      name: "Thalassa",
      orbitalRadius: 28000 * ORBIT_SCALE,
      angle: -2.0,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 700,
      mu: 5635.0,
      atmosphere: 60,
      colors: { inner: "#0b3b6f", mid: "#1579c1", outer: "#031322" }
    },
    {
      // Ember desert (~0.8 g)
      name: "Emberon",
      orbitalRadius: 36000 * ORBIT_SCALE,
      angle: 2.6,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 260,
      mu: 540.8,
      atmosphere: 20,
      colors: { inner: "#5a2610", mid: "#c0551c", outer: "#280904" }
    },
    {
      // Icy mirror world (~0.6 g)
      name: "Mirr",
      orbitalRadius: 48000 * ORBIT_SCALE,
      angle: -1.1,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 400,
      mu: 960.0,
      atmosphere: 10,
      colors: { inner: "#d0e7ff", mid: "#7ca0c8", outer: "#1b2635" }
    },
    {
      // Dark outer rock (~0.16 g)
      name: "Umbral",
      orbitalRadius: 65000 * ORBIT_SCALE,
      angle: 0.9,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 320,
      mu: 163.84,
      atmosphere: 0,
      colors: { inner: "#262b33", mid: "#4b5663", outer: "#090b0f" }
    },
    {
      // Gas giant
      name: "Zephyrus",
      orbitalRadius: 90000 * ORBIT_SCALE,
      angle: -2.5,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 1000,
      mu: 24800.0,
      atmosphere: 150,
      colors: { inner: "#30406b", mid: "#5b7fc0", outer: "#101525" }
    },
    {
      // Remote ice giant
      name: "Noxshade",
      orbitalRadius: 130000 * ORBIT_SCALE,
      angle: 0.3,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 800,
      mu: 7040.0,
      atmosphere: 120,
      colors: { inner: "#485f78", mid: "#7ca3d0", outer: "#0b1018" }
    }
  ];

  const SUN = BODIES[0];
  const MAIN_BODY = BODIES[1];

  function computeSystemRadius() {
    let max = 0;
    for (const b of BODIES) {
      let d;
      if (typeof b.orbitalRadius === "number") {
        d = b.orbitalRadius + b.radius * 2;
      } else {
        d = Math.hypot(b.x - SUN.x, b.y - SUN.y) + b.radius * 2;
      }
      if (d > max) max = d;
    }
    return max;
  }

  const SYSTEM_RADIUS = computeSystemRadius();
  const SYSTEM_ESCAPE_RADIUS = SYSTEM_RADIUS * 2.5;

  // --- Starfield ---------------------------------------------------------
  // Denser + closer so we see stars when zoomed in.
  const STAR_COUNT = 2000;
  const STAR_FIELD_RADIUS = SYSTEM_RADIUS * 2;
  const STARS = [];

  (function initStars() {
    STARS.length = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      const r = STAR_FIELD_RADIUS * Math.sqrt(Math.random());
      const theta = Math.random() * Math.PI * 2;
      STARS.push({
        x: Math.cos(theta) * r,
        y: Math.sin(theta) * r,
        brightness: Math.random(),
        size: 0.7 + Math.random()
      });
    }
  })();

  function initOrbits() {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        body.orbitalSpeed = Math.sqrt(SUN.mu / Math.pow(body.orbitalRadius, 3)) * 0.6;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  function updateBodyPositions(dt) {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        body.angle += body.orbitalSpeed * dt;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  initOrbits();

  function getPrimaryBody(x, y) {
    let best = BODIES[0];
    let bestDist2 = (x - best.x) * (x - best.x) + (y - best.y) * (y - best.y);
    for (let i = 1; i < BODIES.length; i++) {
      const b = BODIES[i];
      const dx = x - b.x;
      const dy = y - b.y;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestDist2) {
        best = b;
        bestDist2 = d2;
      }
    }
    return best;
  }

  // --- Rocket & stages ---------------------------------------------------
  const CORE_MASS = 4;
  const FUEL_DENSITY = 0.01;

  const STAGES_TEMPLATE = [
    {
      name: "Booster",
      maxFuel: 12000,
      fuel: 12000,
      thrust: 32,   // 1/10 original
      dryMass: 6
    },
    {
      name: "Orbiter",
      maxFuel: 7000,
      fuel: 7000,
      thrust: 10,   // 1/10 original
      dryMass: 3
    }
  ];

  const ROT_SPEED = (Math.PI / 180) * 60; // rad/s

  // Rotation warp cap: spin scales with warp up to this, then stops
  function getSpinFactor() {
    const WARP_SPIN_CAP = 8; // feels good; tweak if you want
    if (timeScale <= 1) return 1;
    const effective = Math.min(timeScale, WARP_SPIN_CAP);
    return effective / timeScale;
  }

  let state;

  function cloneStages() {
    return STAGES_TEMPLATE.map(s => ({ ...s }));
  }

  function resetGame() {
    initOrbits();

    const mb = MAIN_BODY;

    const dxSun = mb.x - SUN.x;
    const dySun = mb.y - SUN.y;
    const rPlanet = Math.hypot(dxSun, dySun) || 1;
    const ux = dxSun / rPlanet;
    const uy = dySun / rPlanet;

    const surfaceAltitude = mb.radius + 5;
    const rocketX = mb.x + ux * surfaceAltitude;
    const rocketY = mb.y + uy * surfaceAltitude;

    const omega = mb.orbitalSpeed;
    const vMag = omega * rPlanet;
    const tx = -uy;
    const ty = ux;
    const rocketVx = vMag * tx;
    const rocketVy = vMag * ty;

    const normalAngle = Math.atan2(rocketY - mb.y, rocketX - mb.x);

    state = {
      rocket: {
        x: rocketX,
        y: rocketY,
        vx: rocketVx,
        vy: rocketVy,
        angle: normalAngle,
        thrusting: false
      },
      stages: cloneStages(),
      currentStageIndex: 0,
      crashed: false,
      landed: true,
      landedBody: mb,
      landedAltitude: surfaceAltitude,
      landedNormalAngle: normalAngle,
      escaped: false,
      orbitStable: false,
      orbitBound: false,
      orbitEscaping: false,
      orbitPeriod: null,
      lastPeriapsis: null,
      primaryBody: mb,
      orbitElements: null,
      sunOrbitBound: false,
      sunOrbitElements: null,
      message: "On " + mb.name + "'s surface. Hold ↑ to lift off. Low thrust = long burns.",
      trail: [],
      predictedPath: [],
      time: 0
    };

    cameraFollow = true;
    cameraX = state.rocket.x;
    cameraY = state.rocket.y;

    transferPlan = null;
  }

  resetGame();

  function currentStage() {
    return state.stages[state.currentStageIndex] || null;
  }

  function rocketMass() {
    let mass = CORE_MASS;
    for (let i = state.currentStageIndex; i < state.stages.length; i++) {
      const s = state.stages[i];
      mass += s.dryMass + s.fuel * FUEL_DENSITY;
    }
    return mass;
  }

  // --- Input -------------------------------------------------------------
  const keys = {};
  window.addEventListener("keydown", e => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) {
      e.preventDefault();
    }
    keys[e.code] = true;

    if (e.code === "Space") {
      stageSeparation();
    }
    if (e.code === "KeyR") {
      resetGame();
    }

    if (e.code === "BracketLeft") {
      timeScale = Math.max(MIN_WARP, timeScale / 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }
    if (e.code === "BracketRight") {
      timeScale = Math.min(MAX_WARP, timeScale * 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }

    if (e.code === "Minus") {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / 1.2);
    }
    if (e.code === "Equal") {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * 1.2);
    }

    if (e.code === "KeyF") {
      cameraFollow = !cameraFollow;
      if (cameraFollow) {
        cameraX = state.rocket.x;
        cameraY = state.rocket.y;
        state.message = "Camera: follow ship";
      } else {
        state.message = "Camera: free";
      }
    }

    // Toggle Helion (Sun) orbit overlay
    if (e.code === "KeyO") {
      showSunOrbit = !showSunOrbit;
      state.message = "Sun orbit overlay: " + (showSunOrbit ? "ON" : "OFF");
    }

    if (e.code === "Digit1") setTransferTarget(1);
    if (e.code === "Digit2") setTransferTarget(2);
    if (e.code === "Digit3") setTransferTarget(3);
    if (e.code === "Digit4") setTransferTarget(4);
    if (e.code === "Digit5") setTransferTarget(5);
    if (e.code === "Digit6") setTransferTarget(6);
    if (e.code === "Digit7") setTransferTarget(7);
    if (e.code === "Digit8") setTransferTarget(8);

    if (e.code === "KeyP") {
      createTransferPlan();
    }
  });

  window.addEventListener("keyup", e => {
    keys[e.code] = false;
  });

  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    if (e.deltaY < 0) {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * 1.1);
    } else if (e.deltaY > 0) {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / 1.1);
    }
  }, { passive: false });

  function getScale() {
    const w = canvas.width;
    const h = canvas.height;
    const baseScale = Math.min(w, h) / (SYSTEM_RADIUS * 2);
    return baseScale * cameraZoom;
  }

  canvas.addEventListener("mousedown", e => {
    if (e.button !== 0) return;
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartCamX = cameraX;
    dragStartCamY = cameraY;
    cameraFollow = false;
    state.message = "Camera: free (drag to pan)";
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
  });

  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    const scale = getScale();
    cameraX = dragStartCamX - dx / scale;
    cameraY = dragStartCamY + dy / scale;
  });

  function stageSeparation() {
    if (state.crashed || state.escaped) return;
    if (state.currentStageIndex >= state.stages.length - 1) return;
    state.currentStageIndex++;
    state.message = "Stage separated!";
  }

  // --- Physics step ------------------------------------------------------
  function update(dt) {
    state.time += dt;
    updateBodyPositions(dt);

    const rocket = state.rocket;
    const stage = currentStage();
    if (!rocket) return;

    const spinFactor = getSpinFactor();

    if (state.landed && !state.crashed && !state.escaped) {
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        rocket.angle += ROT_SPEED * dt * spinFactor;
      }
      if (keys["ArrowRight"] || keys["KeyD"]) {
        rocket.angle -= ROT_SPEED * dt * spinFactor;
      }

      const body = state.landedBody || getPrimaryBody(rocket.x, rocket.y);
      state.landedBody = body;

      let bodyVx = 0;
      let bodyVy = 0;
      if (typeof body.orbitalRadius === "number") {
        const rOrbit = body.orbitalRadius;
        const omega = body.orbitalSpeed;
        const angle = body.angle;
        bodyVx = -Math.sin(angle) * rOrbit * omega;
        bodyVy =  Math.cos(angle) * rOrbit * omega;
      }

      const alt = state.landedAltitude != null ? state.landedAltitude : body.radius;
      const normalAngle =
        state.landedNormalAngle != null
          ? state.landedNormalAngle
          : Math.atan2(rocket.y - body.y, rocket.x - body.x);

      rocket.x = body.x + Math.cos(normalAngle) * alt;
      rocket.y = body.y + Math.sin(normalAngle) * alt;
      rocket.vx = bodyVx;
      rocket.vy = bodyVy;

      const wantsThrust = stage && stage.fuel > 0 && (keys["ArrowUp"] || keys["KeyW"]);
      rocket.thrusting = !!wantsThrust;

      if (cameraFollow) {
        cameraX = rocket.x;
        cameraY = rocket.y;
      }

      if (!wantsThrust) {
        return;
      } else {
        state.landed = false;
        state.landedBody = null;
        state.message = "Liftoff from " + body.name + "!";
      }
    }

    if (state.crashed || state.escaped) {
      rocket.thrusting = false;
      return;
    }

    if (keys["ArrowLeft"] || keys["KeyA"]) {
      rocket.angle += ROT_SPEED * dt * spinFactor;
    }
    if (keys["ArrowRight"] || keys["KeyD"]) {
      rocket.angle -= ROT_SPEED * dt * spinFactor;
    }

    if (stage && stage.fuel > 0) {
      rocket.thrusting = (keys["ArrowUp"] || keys["KeyW"]);
    } else {
      rocket.thrusting = false;
    }

        let ax = 0;
    let ay = 0;

    // 1) Find the strongest gravitational pull at the rocket's position
    let dominantAccMag = 0;
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= 1e-3) continue; // avoid divide-by-zero if we're basically at the center
      const gMag = body.mu / (r * r);
      if (!isFinite(gMag)) continue;
      if (gMag > dominantAccMag) dominantAccMag = gMag;
    }

    // 2) Apply gravity only from bodies that matter (>= a few % of dominant)
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= 1e-3) continue;

      const gMag = body.mu / (r * r);
      if (!isFinite(gMag)) continue;

      // If this body's pull is tiny compared to the dominant one, ignore it
      if (dominantAccMag > 0 && gMag < dominantAccMag * GRAV_PERTURB_THRESHOLD) {
        continue;
      }

      const gravAccMag = -gMag;
      ax += gravAccMag * (dx / r);
      ay += gravAccMag * (dy / r);
    }


    if (rocket.thrusting && stage && stage.fuel > 0) {
      const mass = rocketMass();
      const thrustAcc = stage.thrust / mass;
      const tx = Math.cos(rocket.angle) * thrustAcc;
      const ty = Math.sin(rocket.angle) * thrustAcc;
      ax += tx;
      ay += ty;

      const fuelUseRate = 25;
      const dfuel = fuelUseRate * dt;
      stage.fuel = Math.max(0, stage.fuel - dfuel);
      if (stage.fuel <= 0) {
        rocket.thrusting = false;
        state.message = stage.name + " out of fuel.";
      }
    }

    rocket.vx += ax * dt;
    rocket.vy += ay * dt;
    rocket.x += rocket.vx * dt;
    rocket.y += rocket.vy * dt;

    if (state.time % 0.02 < dt) {
      state.trail.push({ x: rocket.x, y: rocket.y });
      if (state.trail.length > 500) {
        state.trail.shift();
      }
    }

    let collidedBody = null;
    let minDist = Infinity;
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= body.radius && r < minDist) {
        minDist = r;
        collidedBody = body;
      }
    }

    const speed = Math.hypot(rocket.vx, rocket.vy);

    if (collidedBody) {
      if (collidedBody === SUN || speed >= 3) {
        state.crashed = true;
        state.message = "CRASH into " + collidedBody.name + "! Press R to retry.";
        return;
      } else {
        state.landed = true;
        state.landedBody = collidedBody;
        state.landedAltitude = collidedBody.radius;
        state.landedNormalAngle = Math.atan2(rocket.y - collidedBody.y, rocket.x - collidedBody.x);
        rocket.vx = 0;
        rocket.vy = 0;
        state.message = "Nice landing on " + collidedBody.name + "! Hold ↑ to take off or R to reset.";
        return;
      }
    }

    classifyOrbit();

    if (cameraFollow) {
      cameraX = rocket.x;
      cameraY = rocket.y;
    }
  }

  // --- Orbit classification ----------------------------------------------
  function classifyOrbit() {
    const rocket = state.rocket;
    const body = getPrimaryBody(rocket.x, rocket.y);
    state.primaryBody = body;

    const rx = rocket.x - body.x;
    const ry = rocket.y - body.y;
    const r = Math.hypot(rx, ry);

    let bodyVx = 0;
    let bodyVy = 0;
    if (typeof body.orbitalRadius === "number") {
      const rOrbit = body.orbitalRadius;
      const omega = body.orbitalSpeed;
      const angle = body.angle;
      bodyVx = -Math.sin(angle) * rOrbit * omega;
      bodyVy =  Math.cos(angle) * rOrbit * omega;
    }

    const vxRel = rocket.vx - bodyVx;
    const vyRel = rocket.vy - bodyVy;
    const v2 = vxRel * vxRel + vyRel * vyRel;
    const mu = body.mu;

    const specificEnergy = 0.5 * v2 - mu / r;

    state.orbitStable = false;
    state.orbitBound = false;
    state.orbitEscaping = false;
    state.orbitPeriod = null;
    state.orbitElements = null;

    if (specificEnergy > 0) {
      state.orbitEscaping = true;
      state.lastPeriapsis = null;
    } else if (specificEnergy < 0) {
      state.orbitBound = true;

      const h = rx * vyRel - ry * vxRel;
      const a = -mu / (2 * specificEnergy);
      let e2 = 1 - (h * h) / (a * mu);
      if (e2 < 0) e2 = 0;
      const e = Math.sqrt(e2);
      const rp = a * (1 - e);

      state.lastPeriapsis = rp - body.radius;
      state.orbitPeriod = 2 * Math.PI * Math.sqrt(Math.pow(a, 3) / mu);

      if (isFinite(a) && e >= 0) {
        const rdotv = rx * vxRel + ry * vyRel;
        const factor1 = (v2 - mu / r) / mu;
        const factor2 = rdotv / mu;

        let ex = factor1 * rx - factor2 * vxRel;
        let ey = factor1 * ry - factor2 * vyRel;
        let emag = Math.hypot(ex, ey);

        if (emag < 1e-6) {
          ex = rx / r;
          ey = ry / r;
          emag = 1;
        }

        const ehatx = ex / emag;
        const ehaty = ey / emag;

        const rpRadius = a * (1 - e);
        const raRadius = a * (1 + e);

        const periX = body.x + ehatx * rpRadius;
        const periY = body.y + ehaty * rpRadius;
        const apoX  = body.x - ehatx * raRadius;
        const apoY  = body.y - ehaty * raRadius;

        state.orbitElements = {
          bodyName: body.name,
          bodyX: body.x,
          bodyY: body.y,
          periRadius: rpRadius,
          apoRadius: raRadius,
          periX,
          periY,
          apoX,
          apoY
        };
      }

      const atmo = body.atmosphere || 0;
      if (rp > body.radius + atmo) {
        state.orbitStable = true;
        if (!state.message.startsWith("Stable orbit around")) {
          state.message = "Stable orbit around " + body.name + " achieved!";
        }
      }
       } else {
      state.lastPeriapsis = null;
    }

    // --- Helion (Sun)-centric orbit for overlay ------------------------
    {
      const sx = rocket.x - SUN.x;
      const sy = rocket.y - SUN.y;
      const rSun = Math.hypot(sx, sy);
      const vxSun = rocket.vx;
      const vySun = rocket.vy;
      const muSun = SUN.mu;

      const v2Sun = vxSun * vxSun + vySun * vySun;
      const epsSun = 0.5 * v2Sun - muSun / rSun;

      state.sunOrbitBound = false;
      state.sunOrbitElements = null;

      if (epsSun < 0) {
        const hSun = sx * vySun - sy * vxSun;
        const aSun = -muSun / (2 * epsSun);
        let e2Sun = 1 - (hSun * hSun) / (aSun * muSun);
        if (e2Sun < 0) e2Sun = 0;
        const eSun = Math.sqrt(e2Sun);
        const rpSun = aSun * (1 - eSun);
        const raSun = aSun * (1 + eSun);

        if (isFinite(aSun) && eSun >= 0) {
          const rdotvSun = sx * vxSun + sy * vySun;
          const factor1 = (v2Sun - muSun / rSun) / muSun;
          const factor2 = rdotvSun / muSun;

          let exSun = factor1 * sx - factor2 * vxSun;
          let eySun = factor1 * sy - factor2 * vySun;
          let emagSun = Math.hypot(exSun, eySun);
          if (emagSun < 1e-6) {
            exSun = sx / rSun;
            eySun = sy / rSun;
            emagSun = 1;
          }

          const ehatxSun = exSun / emagSun;
          const ehatySun = eySun / emagSun;

          const periXSun = SUN.x + ehatxSun * rpSun;
          const periYSun = SUN.y + ehatySun * rpSun;
          const apoXSun  = SUN.x - ehatxSun * raSun;
          const apoYSun  = SUN.y - ehatySun * raSun;

          state.sunOrbitBound = true;
          state.sunOrbitElements = {
            bodyName: SUN.name,
            bodyX: SUN.x,
            bodyY: SUN.y,
            periRadius: rpSun,
            apoRadius: raSun,
            periX: periXSun,
            periY: periYSun,
            apoX: apoXSun,
            apoY: apoYSun
          };
        }
      }
    }

    // System escape check
    const distFromOrigin = Math.hypot(rocket.x, rocket.y);
    if (!state.escaped && distFromOrigin > SYSTEM_ESCAPE_RADIUS) {
      state.escaped = true;
      state.message = "You escaped the system! Press R to restart.";
    }
  }


  // --- Hohmann transfer planner -----------------------------------------
  function createTransferPlan() {
    const rocket = state.rocket;
    if (!rocket) return;

    const origin = state.primaryBody || getPrimaryBody(rocket.x, rocket.y);
    const originIndex = BODIES.indexOf(origin);
    const destIndex = transferTargetIndex;

    if (originIndex <= 0 || destIndex <= 0) {
      state.message = "Planner: origin and destination must be planets (not Helion).";
      transferPlan = null;
      return;
    }

    const dest = BODIES[destIndex];

    if (typeof origin.orbitalRadius !== "number" || typeof dest.orbitalRadius !== "number") {
      state.message = "Planner: both bodies must orbit Helion.";
      transferPlan = null;
      return;
    }

    const r1 = origin.orbitalRadius;
    const r2 = dest.orbitalRadius;

    if (r2 <= r1) {
      state.message = "Planner: only inner → outer Hohmann supported.";
      transferPlan = null;
      return;
    }

    const mu = SUN.mu;

    const a_t = (r1 + r2) / 2;
    const tTransfer = Math.PI * Math.sqrt((a_t * a_t * a_t) / mu);

    const v1 = Math.sqrt(mu / r1);
    const v2 = Math.sqrt(mu / r2);

    const vTrans1 = Math.sqrt(mu * (2 / r1 - 1 / a_t));
    const vTrans2 = Math.sqrt(mu * (2 / r2 - 1 / a_t));

    const deltaV1 = vTrans1 - v1;
    const deltaV2 = v2 - vTrans2;

    const omegaOrigin = origin.orbitalSpeed;
    const omegaDest = dest.orbitalSpeed;

    const phaseTarget = normalizeAngle(Math.PI - omegaDest * tTransfer);
    const periAngle = origin.angle;

    transferPlan = {
      originIndex,
      destIndex,
      r1,
      r2,
      a_t,
      tTransfer,
      deltaV1,
      deltaV2,
      phaseTarget,
      periAngle,
      omegaOrigin,
      omegaDest
    };

    state.message = "Planner: Hohmann " + origin.name + " → " + dest.name + " created. Burn when phase error ≈ 0°.";
  }

  // --- Predictive path ---------------------------------------------------
  function updatePredictedPath() {
    const rocket = state.rocket;
    if (!rocket || state.crashed || state.landed) {
      state.predictedPath = [];
      return;
    }

    let x = rocket.x;
    let y = rocket.y;
    let vx = rocket.vx;
    let vy = rocket.vy;

    const predicted = [];

    // Longer horizon + slightly larger max radius to match blown-up system.
    const dt = 0.1;
    const steps = 10000;                 // 10000 * 0.1 = 1000 seconds
    const maxRadius = SYSTEM_ESCAPE_RADIUS * 3;

    const predBodies = BODIES.map(b => ({
      name: b.name,
      x: b.x,
      y: b.y,
      radius: b.radius,
      mu: b.mu,
      atmosphere: b.atmosphere || 0,
      orbitalRadius: b.orbitalRadius,
      angle: b.angle,
      orbitalSpeed: b.orbitalSpeed
    }));

    const predSun = predBodies[0];

    for (let i = 0; i < steps; i++) {
      for (let j = 1; j < predBodies.length; j++) {
        const pb = predBodies[j];
        if (typeof pb.orbitalRadius === "number" && typeof pb.orbitalSpeed === "number") {
          pb.angle += pb.orbitalSpeed * dt;
          pb.x = predSun.x + Math.cos(pb.angle) * pb.orbitalRadius;
          pb.y = predSun.y + Math.sin(pb.angle) * pb.orbitalRadius;
        }
      }

      let hit = false;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= body.radius) {
          hit = true;
          break;
        }
      }
      if (hit) break;

      const distFromOrigin = Math.hypot(x, y);
      if (distFromOrigin > maxRadius) break;

            let ax = 0;
      let ay = 0;

      // 1) Dominant gravity at the predicted position
      let dominantAccMag = 0;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= 1e-3) continue;
        const gMag = body.mu / (r * r);
        if (!isFinite(gMag)) continue;
        if (gMag > dominantAccMag) dominantAccMag = gMag;
      }

      // 2) Apply only significant contributors
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= 1e-3) continue;

        const gMag = body.mu / (r * r);
        if (!isFinite(gMag)) continue;

        if (dominantAccMag > 0 && gMag < dominantAccMag * GRAV_PERTURB_THRESHOLD) {
          continue;
        }

        const gravAccMag = -gMag;
        ax += gravAccMag * (dx / r);
        ay += gravAccMag * (dy / r);
      }

      vx += ax * dt;
      vy += ay * dt;

      x += vx * dt;
      y += vy * dt;

      if (i % 8 === 0) {
        predicted.push({ x, y });
      }
    }

    state.predictedPath = predicted;
  }

  // --- Drawing -----------------------------------------------------------
  function draw() {
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const scale = getScale();
    const centerX = w / 2;
    const centerY = h / 2;

    function worldToScreen(x, y) {
      return {
        x: centerX + (x - cameraX) * scale,
        y: centerY - (y - cameraY) * scale
      };
    }

    function screenWithinBounds(p) {
      return (
        p.x > -SAFE_COORD && p.x < SAFE_COORD &&
        p.y > -SAFE_COORD && p.y < SAFE_COORD
      );
    }

    // --- Starfield background -------------------------------------------
        // --- Starfield background -------------------------------------------
    ctx.save();
    // Smaller stars overall; they grow slightly as you zoom in, but stay tiny when zoomed out
    const baseStarSize = 0.45 + 0.18 * Math.log10(1 + cameraZoom); // ~0.45 → ~1px typical
    for (const s of STARS) {
      const p = worldToScreen(s.x, s.y);
      if (p.x < -50 || p.x > w + 50 || p.y < -50 || p.y > h + 50) continue;

      const alpha = 0.25 + s.brightness * 0.6;
      const r = baseStarSize * (0.6 + 0.8 * s.size); // keep variety but keep them small

      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
    }
    ctx.restore();


    // Orbital paths (Helion-centered dashed circles)
    ctx.save();
    ctx.strokeStyle = "rgba(255, 255, 255, 0.12)";
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 6]);

    const sunScreen = worldToScreen(SUN.x, SUN.y);
    const maxOrbitScreenRadius = Math.max(w, h) * 1.2;

    for (const body of BODIES) {
      if (typeof body.orbitalRadius === "number") {
        const rPx = body.orbitalRadius * scale;
        if (rPx < 1 || rPx > SAFE_ORBIT_RADIUS_PX || rPx > maxOrbitScreenRadius) continue;
        ctx.beginPath();
        ctx.arc(sunScreen.x, sunScreen.y, rPx, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    ctx.restore();

    // Hohmann transfer orbit (if any)
    if (transferPlan) {
      const { r1, r2, a_t, periAngle } = transferPlan;
      const maxR = Math.max(r1, r2);
      const maxRPx = maxR * scale;
      const maxTransferRadius = Math.max(w, h) * 1.2;

      if (maxRPx < SAFE_ORBIT_RADIUS_PX && maxRPx < maxTransferRadius) {
        const eTran = (r2 - r1) / (r2 + r1);

        ctx.save();
        ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 120;
        for (let i = 0; i <= steps; i++) {
          const f = (Math.PI * i) / steps;
          const r = a_t * (1 - eTran * eTran) / (1 + eTran * Math.cos(f));
          const theta = periAngle + f;

          const x = SUN.x + r * Math.cos(theta);
          const y = SUN.y + r * Math.sin(theta);

          const p = worldToScreen(x, y);
          const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      }
    }

         // Bodies: Helion + planets
    for (const body of BODIES) {
      ctx.save();
      const screen = worldToScreen(body.x, body.y);
      const rPx = body.radius * scale;

      // Icon mode when zoomed way out so planets stay visible
      const MIN_ICON_RADIUS = 3;
      const useIcon = rPx < MIN_ICON_RADIUS * 2;
      const drawRadius = useIcon ? MIN_ICON_RADIUS : rPx;

      // Culling based on what we'll actually draw
      const margin = Math.max(w, h) * 0.6 + drawRadius;
      if (screen.x < -margin || screen.x > w + margin ||
          screen.y < -margin || screen.y > h + margin) {
        ctx.restore();
        continue;
      }

      if (useIcon) {
        // Tiny map-style dot, lightly colored
        const midColor = (body.colors && body.colors.mid) || "#ffffff";
        ctx.fillStyle = (body === SUN) ? "#ffd080" : midColor;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, drawRadius, 0, Math.PI * 2);
        ctx.fill();
      } else {
        const c = body.colors;
        const planetRadius = drawRadius;

        // Base disc with soft lighting
        const coreGradient = ctx.createRadialGradient(
          screen.x - planetRadius * 0.35,
          screen.y - planetRadius * 0.35,
          planetRadius * 0.2,
          screen.x,
          screen.y,
          planetRadius
        );
        coreGradient.addColorStop(0, c.inner);
        coreGradient.addColorStop(0.5, c.mid);
        coreGradient.addColorStop(1, c.outer);

        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, planetRadius, 0, Math.PI * 2);
        ctx.fill();

        // Rim light / specular highlight
        const rimGrad = ctx.createRadialGradient(
          screen.x + planetRadius * 0.2,
          screen.y - planetRadius * 0.4,
          planetRadius * 0.6,
          screen.x,
          screen.y,
          planetRadius * 1.3
        );
        rimGrad.addColorStop(0, "rgba(255,255,255,0.35)");
        rimGrad.addColorStop(0.4, "rgba(255,255,255,0.10)");
        rimGrad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = rimGrad;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, planetRadius, 0, Math.PI * 2);
        ctx.fill();

        // Special banding for gas/ice giants
        if (body.name === "Zephyrus" || body.name === "Noxshade") {
          ctx.save();
          // Clip to planet disc
          ctx.beginPath();
          ctx.arc(screen.x, screen.y, planetRadius, 0, Math.PI * 2);
          ctx.clip();

          const bandCount = 6;
          for (let i = 0; i < bandCount; i++) {
            const t = i / (bandCount - 1);
            const y = screen.y - planetRadius + t * 2 * planetRadius;

            const bandGrad = ctx.createLinearGradient(
              screen.x - planetRadius, y,
              screen.x + planetRadius, y
            );
            const base = body.colors.mid;
            bandGrad.addColorStop(0, base);
            bandGrad.addColorStop(0.5, "rgba(255,255,255,0.18)");
            bandGrad.addColorStop(1, base);

            ctx.fillStyle = bandGrad;
            ctx.globalAlpha = 0.16 + 0.08 * Math.sin(t * Math.PI);
            ctx.fillRect(
              screen.x - planetRadius,
              y - planetRadius / bandCount,
              planetRadius * 2,
              (2 * planetRadius) / bandCount
            );
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }

        // Thin atmospheric glow if present
        const atmo = body.atmosphere || 0;
        if (atmo > 0) {
          const atmoRadiusPx = (body.radius + atmo) * scale;
          if (atmoRadiusPx < SAFE_ORBIT_RADIUS_PX) {
            const atmoGrad = ctx.createRadialGradient(
              screen.x,
              screen.y,
              planetRadius,
              screen.x,
              screen.y,
              atmoRadiusPx
            );
            atmoGrad.addColorStop(0, "rgba(135,206,255,0.0)");
            atmoGrad.addColorStop(1, "rgba(135,206,255,0.35)");

            ctx.strokeStyle = atmoGrad;
            ctx.lineWidth = Math.max(1, atmoRadiusPx - planetRadius);
            ctx.beginPath();
            ctx.arc(
              screen.x,
              screen.y,
              (planetRadius + atmoRadiusPx) / 2,
              0,
              Math.PI * 2
            );
            ctx.stroke();
          }
        }
      }

      // Labels – hide when super zoomed-out icon mode to avoid clutter
      if (!useIcon || cameraZoom > 0.4) {
        ctx.fillStyle = "#ffffff";
        ctx.font = "11px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText(body.name, screen.x, screen.y + drawRadius + 4);
      }

      ctx.restore();
    }



    // Predicted trajectory (thicker + visible across zoom levels)
    if (state.predictedPath && state.predictedPath.length > 1) {
      ctx.save();
      ctx.setLineDash([6, 4]);
      ctx.lineWidth = Math.max(1, Math.min(3, cameraZoom * 0.15));
      ctx.strokeStyle = "rgba(255, 255, 0, 0.9)";
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.predictedPath.length; i++) {
        const p = worldToScreen(state.predictedPath[i].x, state.predictedPath[i].y);
        const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Trail
    if (state.trail.length > 1) {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(180,180,255,0.6)";
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.trail.length; i++) {
        const p = worldToScreen(state.trail[i].x, state.trail[i].y);
        const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Apsis markers + analytic orbit ellipse for current bound orbit
    if (state.orbitBound && state.orbitElements) {
      const oe = state.orbitElements;

      const periScreen = worldToScreen(oe.periX, oe.periY);
      const apoScreen  = worldToScreen(oe.apoX, oe.apoY);
      const bodyScreen = worldToScreen(oe.bodyX, oe.bodyY);

      (function drawOrbitEllipse() {
        const rp = oe.periRadius;
        const ra = oe.apoRadius;
        const a  = (rp + ra) / 2;
        if (!isFinite(a) || a <= 0) return;

        let e = 1 - rp / a;
        if (!isFinite(e) || e < 0) e = 0;
        if (e > 0.999) e = 0.999;

        const maxR = ra;
        const maxRPx = maxR * scale;
        if (maxRPx < 1 || maxRPx > SAFE_ORBIT_RADIUS_PX) return;

        let px = oe.periX - oe.bodyX;
        let py = oe.periY - oe.bodyY;
        let plen = Math.hypot(px, py);
        if (plen < 1e-6) return;

        const pHatX = px / plen;
        const pHatY = py / plen;
        const qHatX = -pHatY;
        const qHatY =  pHatX;

        ctx.save();
        ctx.strokeStyle = "rgba(80,180,255,0.9)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 240;
        for (let i = 0; i <= steps; i++) {
          const f = (2 * Math.PI * i) / steps;
          const r = a * (1 - e * e) / (1 + e * Math.cos(f));
          if (!isFinite(r) || r <= 0) continue;

          const cosf = Math.cos(f);
          const sinf = Math.sin(f);

          const worldX =
            oe.bodyX + r * (cosf * pHatX + sinf * qHatX);
          const worldY =
            oe.bodyY + r * (cosf * pHatY + sinf * qHatY);

          const p = worldToScreen(worldX, worldY);
          const onScreen =
            p.x >= -50 && p.x <= w + 50 &&
            p.y >= -50 && p.y <= h + 50;

          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      })();

      if (screenWithinBounds(periScreen) || screenWithinBounds(apoScreen) || screenWithinBounds(bodyScreen)) {
        ctx.save();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;

        ctx.strokeStyle = "rgba(0,255,136,0.5)";
        ctx.beginPath();
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(periScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(periScreen.x, periScreen.y);
        }
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(apoScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(apoScreen.x, apoScreen.y);
        }
        ctx.stroke();

        if (screenWithinBounds(periScreen)) {
          ctx.fillStyle = "#00ff88";
          ctx.beginPath();
          ctx.arc(periScreen.x, periScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#00ff88";
          ctx.fillText("Pe", periScreen.x + 6, periScreen.y - 2);
        }

        if (screenWithinBounds(apoScreen)) {
          ctx.fillStyle = "#ff66ff";
          ctx.beginPath();
          ctx.arc(apoScreen.x, apoScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#ff66ff";
          ctx.fillText("Ap", apoScreen.x + 6, apoScreen.y - 2);
        }

        ctx.restore();
      }
    }

        // Sun-centric (Helion) orbit ellipse + Pe/Ap overlay (toggleable)
    if (showSunOrbit && state.sunOrbitBound && state.sunOrbitElements && state.primaryBody !== SUN) {
      const oeS = state.sunOrbitElements;

      const periScreenS = worldToScreen(oeS.periX, oeS.periY);
      const apoScreenS  = worldToScreen(oeS.apoX, oeS.apoY);
      const bodyScreenS = worldToScreen(oeS.bodyX, oeS.bodyY);

      (function drawSunOrbitEllipse() {
        const rpS = oeS.periRadius;
        const raS = oeS.apoRadius;
        const aS  = (rpS + raS) / 2;
        if (!isFinite(aS) || aS <= 0) return;

        let eS = 1 - rpS / aS;
        if (!isFinite(eS) || eS < 0) eS = 0;
        if (eS > 0.999) eS = 0.999;

        const maxR = raS;
        const maxRPx = maxR * scale;
        if (maxRPx < 1 || maxRPx > SAFE_ORBIT_RADIUS_PX) return;

        let pxS = oeS.periX - oeS.bodyX;
        let pyS = oeS.periY - oeS.bodyY;
        let plenS = Math.hypot(pxS, pyS);
        if (plenS < 1e-6) return;

        const pHatXS = pxS / plenS;
        const pHatYS = pyS / plenS;
        const qHatXS = -pHatYS;
        const qHatYS =  pHatXS;

        ctx.save();
        ctx.strokeStyle = "rgba(0,255,200,0.8)"; // cyan-ish for Helion orbit
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 3]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 260;
        for (let i = 0; i <= steps; i++) {
          const f = (2 * Math.PI * i) / steps;
          const r = aS * (1 - eS * eS) / (1 + eS * Math.cos(f));
          if (!isFinite(r) || r <= 0) continue;

          const cosf = Math.cos(f);
          const sinf = Math.sin(f);

          const worldX =
            oeS.bodyX + r * (cosf * pHatXS + sinf * qHatXS);
          const worldY =
            oeS.bodyY + r * (cosf * pHatYS + sinf * qHatYS);

          const p = worldToScreen(worldX, worldY);
          const onScreen =
            p.x >= -50 && p.x <= w + 50 &&
            p.y >= -50 && p.y <= h + 50;

          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      })();

      if (screenWithinBounds(periScreenS) || screenWithinBounds(apoScreenS) || screenWithinBounds(bodyScreenS)) {
        ctx.save();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;

        // Lines from Helion to Sun Pe/Ap
        ctx.strokeStyle = "rgba(0,255,200,0.4)";
        ctx.beginPath();
        if (screenWithinBounds(bodyScreenS) && screenWithinBounds(periScreenS)) {
          ctx.moveTo(bodyScreenS.x, bodyScreenS.y);
          ctx.lineTo(periScreenS.x, periScreenS.y);
        }
        if (screenWithinBounds(bodyScreenS) && screenWithinBounds(apoScreenS)) {
          ctx.moveTo(bodyScreenS.x, bodyScreenS.y);
          ctx.lineTo(apoScreenS.x, apoScreenS.y);
        }
        ctx.stroke();

        // Periapsis marker (Sun)
        if (screenWithinBounds(periScreenS)) {
          ctx.fillStyle = "#00ffd5";
          ctx.beginPath();
          ctx.arc(periScreenS.x, periScreenS.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillText("Pe☉", periScreenS.x + 6, periScreenS.y - 2);
        }

        // Apoapsis marker (Sun)
        if (screenWithinBounds(apoScreenS)) {
          ctx.fillStyle = "#ff99ff";
          ctx.beginPath();
          ctx.arc(apoScreenS.x, apoScreenS.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillText("Ap☉", apoScreenS.x + 6, apoScreenS.y - 2);
        }

        ctx.restore();
      }
    }


    // Rocket
    const rocket = state.rocket;
    const rocketScreen = worldToScreen(rocket.x, rocket.y);

    ctx.save();
    ctx.translate(rocketScreen.x, rocketScreen.y);
    ctx.rotate(-rocket.angle + Math.PI / 2);

    const bodyWidth = 6;
    const bodyHeight = 20;

    const stageIndex = state.currentStageIndex;
    const colors = ["#dddddd", "#ffcc66", "#99ccff"];
    const bodyColor = colors[Math.min(colors.length - 1, stageIndex + 1)];

    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.7);
    ctx.lineTo(bodyWidth / 2, bodyHeight * 0.3);
    ctx.lineTo(0, bodyHeight * 0.5);
    ctx.lineTo(-bodyWidth / 2, bodyHeight * 0.3);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.9);
    ctx.lineTo(bodyWidth / 2, -bodyHeight * 0.7);
    ctx.lineTo(-bodyWidth / 2, -bodyHeight * 0.7);
    ctx.closePath();
    ctx.fill();

    if (rocket.thrusting && !state.crashed && !state.landed) {
      ctx.fillStyle = "#ff9933";
      ctx.beginPath();
      ctx.moveTo(0, bodyHeight * 0.5);
      ctx.lineTo(bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.lineTo(-bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // HUD
    const primary = state.primaryBody || getPrimaryBody(rocket.x, rocket.y);
    const dxp = rocket.x - primary.x;
    const dyp = rocket.y - primary.y;
    const rPrimary = Math.hypot(dxp, dyp);
    const alt = rPrimary - primary.radius;
    const speed = Math.hypot(rocket.vx, rocket.vy);
    const radialVel = (dxp * rocket.vx + dyp * rocket.vy) / rPrimary;

    const stage = currentStage();
    const stageName = stage ? stage.name : "None";
    const fuel = stage ? stage.fuel : 0;
    const maxFuel = stage ? stage.maxFuel : 1;
    const fuelPct = Math.max(0, Math.min(100, (fuel / maxFuel) * 100));

    let orbitStatus;
    if (state.orbitEscaping) {
      orbitStatus = state.escaped ? "Escaped system" : "Escaping " + primary.name;
    } else if (state.orbitStable) {
      orbitStatus = "Stable orbit around " + primary.name;
    } else if (state.orbitBound) {
      orbitStatus = "Bound to " + primary.name + " (reentry)";
    } else {
      orbitStatus = "Suborbital / transitioning";
    }

    const periapsisText =
      state.lastPeriapsis != null
        ? (state.lastPeriapsis >= 0
            ? state.lastPeriapsis.toFixed(1) + " km"
            : "surface")
        : "unknown";

    const apoapsisText =
      state.orbitElements && state.orbitBound
        ? (state.orbitElements.apoRadius - primary.radius).toFixed(1) + " km"
        : "unknown";

    const camModeText = cameraFollow ? "Follow ship" : "Free";

    overlay.textContent =
      "BODY: " + primary.name + "\n" +
      "ALT: " + alt.toFixed(1) + " km\n" +
      "SPEED: " + speed.toFixed(2) + " km/s\n" +
      "VERT SPD: " + radialVel.toFixed(2) + " km/s (" + (radialVel >= 0 ? "↑" : "↓") + ")\n" +
      "STAGE: " + stageName + " (" + fuelPct.toFixed(0) + "% fuel)\n" +
      "ORBIT: " + orbitStatus + "\n" +
      "Periapsis: " + periapsisText + "\n" +
      "Apoapsis: " + apoapsisText + "\n" +
      "WARP: " + timeScale.toFixed(2) + "x\n" +
      "ZOOM: " + cameraZoom.toFixed(2) + "x\n" +
      "CAM: " + camModeText + "\n";

    if (transferPlan) {
      const origin = BODIES[transferPlan.originIndex];
      const dest = BODIES[transferPlan.destIndex];

      const currentPhase = normalizeAngle(dest.angle - origin.angle);
      const phaseErrorRad = smallestAngleDiff(transferPlan.phaseTarget, currentPhase);
      const phaseErrorDeg = phaseErrorRad * 180 / Math.PI;

      const relOmega = transferPlan.omegaDest - transferPlan.omegaOrigin;
      let timeToWindow = null;
      if (Math.abs(relOmega) > 1e-8) {
        let tRaw = phaseErrorRad / relOmega;
        const synodicPeriod = 2 * Math.PI / Math.abs(relOmega);
        tRaw = ((tRaw % synodicPeriod) + synodicPeriod) % synodicPeriod;
        timeToWindow = tRaw;
      }

      overlay.textContent +=
        "\nTRANSFER: " + origin.name + " → " + dest.name + "\n" +
        "Phase error: " + phaseErrorDeg.toFixed(1) + "°\n" +
        (timeToWindow != null
           ? "Time to window: " + (timeToWindow / 60).toFixed(1) + " min\n"
           : "") +
        "Δv1 (depart): " + transferPlan.deltaV1.toFixed(3) + " km/s\n" +
        "Δv2 (circularize): " + transferPlan.deltaV2.toFixed(3) + " km/s\n";
    }

    overlay.textContent += "\n" + state.message;
  }

  // --- Main loop ---------------------------------------------------------
// --- Main loop ---------------------------------------------------------
let lastTime = performance.now();
let frameCounter = 0;

function loop(now) {
  frameCounter++;

  const realDt = (now - lastTime) / 1000;
  lastTime = now;

  // How much simulation time we *want* to advance this frame
  let simDt = Math.max(0, realDt * timeScale);

  if (simDt > 0) {
    // Physics stepping:
    //  - Small steps at normal warp for stability
    //  - Much larger steps allowed at huge warp so we don't cap out around 10k×

    const BASE_MAX_STEP = 0.5;     // good for normal flight/orbits
    const HIGH_WARP_MAX_STEP = 8.0; // big chunks at huge warp (orbits still fine)
    const HIGH_WARP_THRESHOLD = 5000; // above this, loosen the step size

    const MAX_STEPS_PER_FRAME = 400; // allow more steps if needed

    // Pick the step size based on current warp
    const maxStep = (timeScale >= HIGH_WARP_THRESHOLD)
      ? HIGH_WARP_MAX_STEP
      : BASE_MAX_STEP;

    // How many steps would we need if every step were maxStep?
    let steps = Math.ceil(simDt / maxStep);

    if (steps > MAX_STEPS_PER_FRAME) {
      // Clamp: we effectively cap simDt to what we can afford this frame,
      // but now the cap is much higher at high warp.
      steps = MAX_STEPS_PER_FRAME;
      simDt = steps * maxStep;
    }

    const stepDt = simDt / steps;

    for (let i = 0; i < steps; i++) {
      update(stepDt);
    }
  }

  // At huge warp, the predicted path is expensive and not very useful.
  // So only update it:
  //  - every frame at low warp
  //  - every Nth frame at high warp
  let shouldUpdatePrediction = true;
  if (timeScale > 2000) {
    // e.g. only recompute 1 out of every 10 frames at high warp
    shouldUpdatePrediction = (frameCounter % 10 === 0);
  }

  if (shouldUpdatePrediction) {
    updatePredictedPath();
  }

  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);


})();
</script>
</body>
</html>
