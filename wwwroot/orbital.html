<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Orbital Simulation – The Helion System</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    color: #fff;
  }
  #game {
    display: block;
    background: radial-gradient(circle at 50% 130%, #001018, #000000 65%, #02020a);
  }
  
    #overlay {
    position: fixed;
    inset: 0;
    padding: 8px 14px 14px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    font-size: 13px;
    text-shadow: 0 0 6px #000;
    pointer-events: none;
    box-sizing: border-box;
    background: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0.0),
      rgba(0, 0, 0, 0.25) 60%,
      rgba(0, 0, 0, 0.5)
    );
  }

  /* Futuristic / digital-steampunk HUD */

  .hud-top-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: flex-start;
  }

  .hud-top-row--secondary {
    margin-top: 4px;
  }

  .hud-bottom-panel {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .hud-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: center;
  }

  .hud-chip {
    background: radial-gradient(circle at 20% 0%, rgba(255,255,255,0.09), rgba(10,10,15,0.96));
    border: 1px solid rgba(210,160,90,0.45);
    box-shadow:
      0 0 6px rgba(0,0,0,0.9),
      0 0 12px rgba(255,200,120,0.18);
    border-radius: 7px;
    padding: 4px 8px 5px;
    min-width: 92px;
    max-width: 260px;
    backdrop-filter: blur(4px);
    pointer-events: none;
  }

  .hud-chip--wide {
    flex: 1 1 260px;
  }

  .hud-label {
    display: block;
    font-size: 9px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #ffddaa;
    opacity: 0.9;
    margin-bottom: 2px;
  }

  .hud-value {
    font-family: "SF Mono", "Consolas", "Menlo", monospace;
    font-size: 13px;
    color: #f3f3f3;
    white-space: nowrap;
  }

  .hud-value--large {
    font-size: 14px;
  }

  .hud-odometer {
    display: inline-flex;
    gap: 2px;
    padding: 2px 4px;
    margin-top: 1px;
    background: linear-gradient(to bottom, #26160d, #050308);
    border-radius: 4px;
    border: 1px solid rgba(255,190,120,0.35);
    box-shadow: inset 0 0 6px rgba(0,0,0,0.85);
  }

  .hud-odo-digit {
    min-width: 0.6em;
    padding: 0 1px;
    text-align: center;
    border-radius: 2px;
    background: radial-gradient(circle at 50% 0%, rgba(255,255,255,0.18), rgba(5,5,8,1));
    color: #ffefc0;
    text-shadow: 0 0 4px rgba(255,210,140,0.85);
  }

  .hud-odo-digit--dim {
    opacity: 0.35;
  }

  .hud-odo-sign {
    margin-right: 3px;
    color: #ffb49b;
  }

  .hud-bar {
    position: relative;
    height: 6px;
    border-radius: 999px;
    background: rgba(16,14,10,0.95);
    overflow: hidden;
    margin-top: 3px;
    box-shadow: inset 0 0 3px rgba(0,0,0,0.9);
  }

  .hud-bar-fill {
    position: absolute;
    inset: 1px;
    width: var(--pct, 50%);
    border-radius: 999px;
    background: linearGradient(90deg, #4cf8c0, #ffe477, #ff7b57);
    background: linear-gradient(90deg, #4cf8c0, #ffe477, #ff7b57);
    box-shadow: 0 0 6px rgba(255,220,140,0.9);
  }

  .hud-message {
    text-align: center;
    color: #f8e7c4;
    font-size: 12px;
    margin-top: 4px;
    min-height: 1em;
  }

  .hud-transfer {
    font-size: 11px;
    margin-top: 3px;
    color: #d8f6ff;
    line-height: 1.25;
  }



    /* Help popup panel + toggle button */

      #help-panel {
    position: fixed;
    right: 16px;
    bottom: 56px; /* sits just above the HELP button (which is at bottom:16px) */
    max-width: 360px;
    padding: 10px 14px;
    font-size: 12px;
    line-height: 1.4;
    color: #f8eedc;
    background: radial-gradient(circle at 10% 0%, rgba(255,255,255,0.12), rgba(10,7,4,0.96));
    border: 1px solid rgba(210,160,90,0.65);
    border-radius: 9px;
    box-shadow:
      0 0 10px rgba(0,0,0,0.95),
      0 0 18px rgba(255,205,140,0.25);
    backdrop-filter: blur(5px);
    pointer-events: auto;
    z-index: 40;
    opacity: 1;
    transform: translateY(0);
    transition: opacity 0.22s ease-out, transform 0.22s ease-out;
  }

  #help-panel.help-panel--hidden {
    opacity: 0;
    transform: translateY(10px); /* slide down toward the button as it fades out */
    pointer-events: none;
  }



  #help-panel h2 {
    margin: 0 0 4px;
    font-size: 12px;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: #ffddaa;
  }

  #help-panel .help-section-title {
    font-weight: 600;
    color: #ffe8c6;
    margin-top: 4px;
    margin-bottom: 2px;
  }

  #help-panel .help-keys {
    font-family: "SF Mono", "Consolas", "Menlo", monospace;
    font-size: 11px;
    color: #e6f2ff;
  }

  #help-panel .help-keys span {
    display: inline-block;
    padding: 1px 4px;
    margin-right: 4px;
    margin-bottom: 2px;
    border-radius: 4px;
    border: 1px solid rgba(255,220,160,0.4);
    background: rgba(10,6,4,0.85);
  }

  #help-panel .help-footnote {
    margin-top: 4px;
    font-size: 11px;
    color: #d3c7b7;
    opacity: 0.9;
  }

    #help-toggle {
    position: fixed;
    bottom: 16px;
    right: 16px;
    min-width: 60px;
    padding: 0 10px;
    height: 30px;
    border-radius: 999px;
    border: 1px solid rgba(210,160,90,0.7);
    background: radial-gradient(circle at 30% 0%, rgba(255,255,255,0.18), rgba(10,7,4,0.98));
    box-shadow:
      0 0 8px rgba(0,0,0,0.9),
      0 0 12px rgba(255,215,150,0.35);
    color: #ffe9c7;
    font-family: "SF Mono", "Consolas", "Menlo", monospace;
    font-size: 12px;
    text-align: center;
    line-height: 30px;
    cursor: pointer;
    pointer-events: auto;
    z-index: 41;
  }

  #help-toggle.help-toggle--active {
    box-shadow:
      0 0 10px rgba(255,220,150,0.8),
      0 0 18px rgba(255,240,200,0.6);
    border-color: rgba(255,220,160,0.95);
  }
  /* Difficulty selector: Easy vs Hard fuel */

  #difficulty-panel {
    position: fixed;
    left: 50%;
    bottom: 250px;
    transform: translateX(-50%);
    padding: 8px 14px;
    max-width: 360px;
    background: radial-gradient(circle at 20% 0%, rgba(255,255,255,0.12), rgba(10,7,4,0.96));
    border: 1px solid rgba(210,160,90,0.7);
    border-radius: 10px;
    box-shadow:
      0 0 10px rgba(0,0,0,0.95),
      0 0 18px rgba(255,205,140,0.30);
    font-size: 12px;
    color: #ffe9c7;
    pointer-events: auto;
    z-index: 39; /* below help panel but above HUD */
    opacity: 1;
    transition: opacity 0.25s ease-out, transform 0.25s ease-out;
  }

  #difficulty-panel.difficulty-panel--hidden {
    opacity: 0;
    transform: translate(-50%, 10px);
    pointer-events: none;
  }

  #difficulty-panel h3 {
    margin: 0 0 4px;
    font-size: 11px;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    color: #ffddaa;
  }

  #difficulty-panel p {
    margin: 0 0 6px;
    font-size: 11px;
    color: #f2e0c0;
    opacity: 0.9;
  }

  .difficulty-buttons {
    display: flex;
    gap: 8px;
  }

  .difficulty-button {
    flex: 1 1 auto;
    padding: 5px 10px;
    border-radius: 999px;
    border: 1px solid rgba(210,160,90,0.7);
    background: radial-gradient(circle at 30% 0%, rgba(255,255,255,0.18), rgba(10,7,4,0.98));
    box-shadow:
      0 0 6px rgba(0,0,0,0.85),
      0 0 10px rgba(0,0,0,0.55);
    font-family: "SF Mono", "Consolas", "Menlo", monospace;
    font-size: 11px;
    color: #ffe9c7;
    cursor: pointer;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  .difficulty-button--selected {
    border-color: rgba(255,220,160,0.95);
    box-shadow:
      0 0 10px rgba(255,220,150,0.8),
      0 0 18px rgba(255,240,200,0.6);
    color: #fff8df;
  }


</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>
<div id="difficulty-panel">
  <h3>FUEL MODE</h3>
  <p>Choose your tank size before liftoff.</p>
  <div class="difficulty-buttons">
    <button id="diff-easy"
            class="difficulty-button difficulty-button--selected"
            type="button">
      Easy – full tanks
    </button>
    <button id="diff-hard"
            class="difficulty-button"
            type="button">
      Hard – realistic budget
    </button>
  </div>
</div>

<div id="help-panel">
  <h2>FLIGHT MANUAL</h2>

  <div class="help-section-title">Attitude &amp; Thrust</div>
  <div class="help-keys">
    <span>← / →</span> rotate &nbsp;·&nbsp;
    <span>↑</span> thrust / liftoff &nbsp;·&nbsp;
    <span>SPACE</span> stage
  </div>

  <div class="help-section-title">Time &amp; Camera</div>
  <div class="help-keys">
    <span>[ / ]</span> time warp &nbsp;·&nbsp;
    <span>- / =</span> zoom &nbsp;·&nbsp;
    <span>F</span> follow / free cam &nbsp;·&nbsp;
    mouse wheel zoom &nbsp;·&nbsp; drag to pan (free cam)
  </div>

  <div class="help-section-title">Transfer Planner</div>
  <div class="help-keys">
    <span>1–8</span> select target planet &nbsp;·&nbsp;
    <span>P</span> plan Helion-centered Hohmann (inner → outer)
  </div>

  <div class="help-section-title">Misc</div>
  <div class="help-keys">
    <span>R</span> reset flight &nbsp;·&nbsp;
    <span>O</span> toggle Sun-orbit overlay &nbsp;·&nbsp;
    <span>H</span> toggle this manual
  </div>

  <div class="help-footnote">
    Dashed yellow path: coast-only trajectory under moving Helion + planet gravity.<br>
    Cyan arc: planned transfer orbit. Stable local &amp; Helion orbits are drawn in blue/cyan.
  </div>
</div>

<div id="help-toggle" class="help-toggle--active">HELP</div>



<script>
(function () {
    const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const helpPanel = document.getElementById("help-panel");
  const helpToggle = document.getElementById("help-toggle");
  let helpVisible = true;

    const diffPanel = document.getElementById("difficulty-panel");
  const diffEasyBtn = document.getElementById("diff-easy");
  const diffHardBtn = document.getElementById("diff-hard");

  function updateDifficultyButtons() {
    if (!diffPanel) return;
    if (diffEasyBtn) {
      if (difficulty === "easy") diffEasyBtn.classList.add("difficulty-button--selected");
      else diffEasyBtn.classList.remove("difficulty-button--selected");
    }
    if (diffHardBtn) {
      if (difficulty === "hard") diffHardBtn.classList.add("difficulty-button--selected");
      else diffHardBtn.classList.remove("difficulty-button--selected");
    }
  }

  function showDifficultyPanel() {
    if (!diffPanel) return;
    diffPanel.classList.remove("difficulty-panel--hidden");
    updateDifficultyButtons();
  }

  function hideDifficultyPanel() {
    if (!diffPanel) return;
    diffPanel.classList.add("difficulty-panel--hidden");
  }

  function setDifficultyMode(mode) {
    difficulty = (mode === "hard") ? "hard" : "easy";
    if (state) {
      // Reload stages with the chosen fuel amounts
      state.stages = cloneStages();
      state.currentStageIndex = 0;
      state.message =
        "Difficulty: " +
        (difficulty === "hard" ? "Hard fuel budget loaded." : "Easy fuel budget loaded.");
    }
    updateDifficultyButtons();
  }

 function setHelpVisible(v) {
   helpVisible = v;
   if (!helpPanel || !helpToggle) return;
   if (helpVisible) {
     helpPanel.classList.remove("help-panel--hidden");
     helpToggle.classList.add("help-toggle--active");
   } else {
     helpPanel.classList.add("help-panel--hidden");
     helpToggle.classList.remove("help-toggle--active");
   }
 }
  

  const SAFE_COORD = 1_000_000;
  const SAFE_ORBIT_RADIUS_PX = 20000;

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  // --- Time warp ---------------------------------------------------------
  let timeScale = 1;
  const MIN_WARP = 0.1;
  const MAX_WARP = 50000;   // allow very high warp

  // --- Camera: zoom, pan, follow ----------------------------------------
  const MIN_ZOOM = 0.25;
  const MAX_ZOOM = 10000000;
  let cameraZoom = MAX_ZOOM;

  // Smaller = slower zoom
  const ZOOM_STEP_MOUSE = 1.03; // was 1.1
  const ZOOM_STEP_KEYS  = 1.06; // was 1.2

  let cameraX = 0;
  let cameraY = 0;
  let cameraFollow = true;

  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartCamX = 0;
  let dragStartCamY = 0;

    // --- Transfer planner state -------------------------------------------
  let transferTargetIndex = 3;  // default target
  let transferPlan = null;
  let showSunOrbit = true;


  function normalizeAngle(a) {
    const twoPi = Math.PI * 2;
    a = a % twoPi;
    if (a < 0) a += twoPi;
    return a;
  }

  function smallestAngleDiff(target, current) {
    const t = normalizeAngle(target);
    const c = normalizeAngle(current);
    let d = t - c;
    if (d > Math.PI) d -= 2 * Math.PI;
    if (d < -Math.PI) d += 2 * Math.PI;
    return d;
  }

  function setTransferTarget(index) {
    if (index <= 0 || index >= BODIES.length) return;
    transferTargetIndex = index;
    transferPlan = null;
    if (state) {
      state.message = "Transfer target: " + BODIES[index].name;
    }
  }

  // --- Celestial bodies: Helion + orbiting planets ----------------------
  // Scale orbital radii up to get a larger "solar system".
  const ORBIT_SCALE = 50;

    // Ignore gravitational contributions that are tiny compared to the strongest pull
  const GRAV_PERTURB_THRESHOLD = 0.03; // 3% of dominant acceleration


  const BODIES = [
    {
      // Central star
      name: "Helion",
      x: 0,
      y: 0,
      radius: 1200,
      mu: 4.0176e7,      // high for nice orbital speeds
      atmosphere: 0,
      colors: { inner: "#fff7b3", mid: "#ffcc33", outer: "#d47a1a" }
    },
    {
      // Homeworld – Earth-like (~1 g)
      name: "Astraia",
      orbitalRadius: 15000 * ORBIT_SCALE,
      angle: 0,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 600,
      mu: 3531.6,        // g ≈ 9.81 m/s²
      atmosphere: 40,
      colors: { inner: "#08384f", mid: "#0a5b32", outer: "#021016" }
    },
    {
      // Rocky twilight world (~0.38 g, Mars-ish)
      name: "Nyxos",
      orbitalRadius: 21000 * ORBIT_SCALE,
      angle: 1.4,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 300,
      mu: 333.9,
      atmosphere: 0,
      colors: { inner: "#30213b", mid: "#5b3e7a", outer: "#150d1f" }
    },
    {
      // Ocean world (slightly > 1 g)
      name: "Thalassa",
      orbitalRadius: 28000 * ORBIT_SCALE,
      angle: -2.0,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 700,
      mu: 5635.0,
      atmosphere: 60,
      colors: { inner: "#0b3b6f", mid: "#1579c1", outer: "#031322" }
    },
    {
      // Ember desert (~0.8 g)
      name: "Emberon",
      orbitalRadius: 36000 * ORBIT_SCALE,
      angle: 2.6,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 260,
      mu: 540.8,
      atmosphere: 20,
      colors: { inner: "#5a2610", mid: "#c0551c", outer: "#280904" }
    },
    {
      // Icy mirror world (~0.6 g)
      name: "Mirr",
      orbitalRadius: 48000 * ORBIT_SCALE,
      angle: -1.1,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 400,
      mu: 960.0,
      atmosphere: 10,
      colors: { inner: "#d0e7ff", mid: "#7ca0c8", outer: "#1b2635" }
    },
    {
      // Dark outer rock (~0.16 g)
      name: "Umbral",
      orbitalRadius: 65000 * ORBIT_SCALE,
      angle: 0.9,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 320,
      mu: 163.84,
      atmosphere: 0,
      colors: { inner: "#262b33", mid: "#4b5663", outer: "#090b0f" }
    },
    {
      // Gas giant
      name: "Zephyrus",
      orbitalRadius: 90000 * ORBIT_SCALE,
      angle: -2.5,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 1000,
      mu: 24800.0,
      atmosphere: 150,
      colors: { inner: "#30406b", mid: "#5b7fc0", outer: "#101525" }
    },
    {
      // Remote ice giant
      name: "Noxshade",
      orbitalRadius: 130000 * ORBIT_SCALE,
      angle: 0.3,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 800,
      mu: 7040.0,
      atmosphere: 120,
      colors: { inner: "#485f78", mid: "#7ca3d0", outer: "#0b1018" }
    }
  ];

  const SUN = BODIES[0];
  const MAIN_BODY = BODIES[1];

  function computeSystemRadius() {
    let max = 0;
    for (const b of BODIES) {
      let d;
      if (typeof b.orbitalRadius === "number") {
        d = b.orbitalRadius + b.radius * 2;
      } else {
        d = Math.hypot(b.x - SUN.x, b.y - SUN.y) + b.radius * 2;
      }
      if (d > max) max = d;
    }
    return max;
  }

  const SYSTEM_RADIUS = computeSystemRadius();
  const SYSTEM_ESCAPE_RADIUS = SYSTEM_RADIUS * 2.5;

  // --- Starfield ---------------------------------------------------------
  // Denser + closer so we see stars when zoomed in.
  const STAR_COUNT = 2000;
  const STAR_FIELD_RADIUS = SYSTEM_RADIUS * 2;
  const STARS = [];

  (function initStars() {
    STARS.length = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      const r = STAR_FIELD_RADIUS * Math.sqrt(Math.random());
      const theta = Math.random() * Math.PI * 2;
      STARS.push({
        x: Math.cos(theta) * r,
        y: Math.sin(theta) * r,
        brightness: Math.random(),
        size: 0.7 + Math.random()
      });
    }
  })();

  function initOrbits() {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        body.orbitalSpeed = Math.sqrt(SUN.mu / Math.pow(body.orbitalRadius, 3)) * 0.6;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  function updateBodyPositions(dt) {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        body.angle += body.orbitalSpeed * dt;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  initOrbits();

  function getPrimaryBody(x, y) {
    let best = BODIES[0];
    let bestDist2 = (x - best.x) * (x - best.x) + (y - best.y) * (y - best.y);
    for (let i = 1; i < BODIES.length; i++) {
      const b = BODIES[i];
      const dx = x - b.x;
      const dy = y - b.y;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestDist2) {
        best = b;
        bestDist2 = d2;
      }
    }
    return best;
  }

  // --- Rocket & stages ---------------------------------------------------
  const CORE_MASS = 4;

  // Fuel "density" = mass per fuel unit.
  // Easy: lighter fuel ⇒ same volume weighs less ⇒ higher TWR for the same tank size.
  // Hard: denser fuel ⇒ same volume is heavier ⇒ lower TWR for tighter burns.
  const FUEL_DENSITY_EASY = 0.001;
  const FUEL_DENSITY_HARD = 0.1;

  // Easy mode: big tanks + light fuel
  // Roughly ~9 km/s total Δv (very forgiving).
  const STAGES_EASY = [
    {
      name: "Booster",
      maxFuel: 12000,
      fuel: 12000,
      thrust: 32,   // 1/10 original thrust
      dryMass: 6
    },
    {
      name: "Orbiter",
      maxFuel: 7000,
      fuel: 7000,
      thrust: 10,   // 1/10 original thrust
      dryMass: 3
    }
  ];

  // Hard mode: much smaller tanks + dense fuel
  // Roughly ~4 km/s total Δv if flown well (orbit + transfers but with little slack).
  const STAGES_HARD = [
    {
      name: "Booster",
      maxFuel: 80,
      fuel: 80,
      thrust: 32,
      dryMass: 6
    },
    {
      name: "Orbiter",
      maxFuel: 200,
      fuel: 200,
      thrust: 10,
      dryMass: 3
    }
  ];

  // Helper to pick the active fuel density for the current difficulty.
  function getFuelDensity() {
    // assumes you already have: let difficulty = "easy";
    return difficulty === "hard" ? FUEL_DENSITY_HARD : FUEL_DENSITY_EASY;
  }

  // If you already have getStageTemplate/cloneStages below, make sure they use STAGES_EASY/STAGES_HARD.
  function getStageTemplate() {
    return difficulty === "hard" ? STAGES_HARD : STAGES_EASY;
  }

  function cloneStages() {
    return getStageTemplate().map(s => ({ ...s }));
  }


  // Default: no selection ⇒ Easy mode
  let difficulty = "easy";


  const ROT_SPEED = (Math.PI / 180) * 60; // rad/s

  // Rotation warp cap: spin scales with warp up to this, then stops
  function getSpinFactor() {
    const WARP_SPIN_CAP = 8; // feels good; tweak if you want
    if (timeScale <= 1) return 1;
    const effective = Math.min(timeScale, WARP_SPIN_CAP);
    return effective / timeScale;
  }

  let state;

  function getStageTemplate() {
    return difficulty === "hard" ? STAGES_HARD : STAGES_EASY;
  }

  function cloneStages() {
    return getStageTemplate().map(s => ({ ...s }));
  }


  function resetGame() {
    initOrbits();

    const mb = MAIN_BODY;

    const dxSun = mb.x - SUN.x;
    const dySun = mb.y - SUN.y;
    const rPlanet = Math.hypot(dxSun, dySun) || 1;
    const ux = dxSun / rPlanet;
    const uy = dySun / rPlanet;

    const surfaceAltitude = mb.radius;
    const rocketX = mb.x + ux * surfaceAltitude;
    const rocketY = mb.y + uy * surfaceAltitude;

    const omega = mb.orbitalSpeed;
    const vMag = omega * rPlanet;
    const tx = -uy;
    const ty = ux;
    const rocketVx = vMag * tx;
    const rocketVy = vMag * ty;

    const normalAngle = Math.atan2(rocketY - mb.y, rocketX - mb.x);

    state = {
      rocket: {
        x: rocketX,
        y: rocketY,
        vx: rocketVx,
        vy: rocketVy,
        angle: normalAngle,
        thrusting: false
      },
      stages: cloneStages(),
      currentStageIndex: 0,
      crashed: false,
      landed: true,
      landedBody: mb,
      landedAltitude: surfaceAltitude,
      landedNormalAngle: normalAngle,
      escaped: false,
      orbitStable: false,
      orbitBound: false,
      orbitEscaping: false,
      orbitPeriod: null,
      lastPeriapsis: null,
      primaryBody: mb,
      orbitElements: null,
      sunOrbitBound: false,
      sunOrbitElements: null,
      message: "On " + mb.name + "'s surface. Hold ↑ to lift off. Low thrust = long burns.",
      trail: [],
      predictedPath: [],
      time: 0
    };

    cameraFollow = true;
    cameraX = state.rocket.x;
    cameraY = state.rocket.y;

    transferPlan = null;

    // Fresh flight on the pad – show difficulty selector
    showDifficultyPanel();
    updateDifficultyButtons();
  }

  resetGame();


  function currentStage() {
    return state.stages[state.currentStageIndex] || null;
  }
  function rocketMass() {
    const fuelDensity = getFuelDensity();
    let mass = CORE_MASS;
    for (let i = state.currentStageIndex; i < state.stages.length; i++) {
      const s = state.stages[i];
      mass += s.dryMass + s.fuel * fuelDensity;
    }
    return mass;
  }


  // --- Input -------------------------------------------------------------
  const keys = {};
  window.addEventListener("keydown", e => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) {
      e.preventDefault();
    }
    keys[e.code] = true;

    if (e.code === "Space") {
      stageSeparation();
    }
    if (e.code === "KeyR") {
      resetGame();
    }

    if (e.code === "BracketLeft") {
      timeScale = Math.max(MIN_WARP, timeScale / 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }
    if (e.code === "BracketRight") {
      timeScale = Math.min(MAX_WARP, timeScale * 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }

    if (e.code === "Minus") {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / 1.2);
    }
    if (e.code === "Equal") {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * 1.2);
    }

    if (e.code === "KeyF") {
      cameraFollow = !cameraFollow;
      if (cameraFollow) {
        cameraX = state.rocket.x;
        cameraY = state.rocket.y;
        state.message = "Camera: follow ship";
      } else {
        state.message = "Camera: free";
      }
    }

    // Toggle Helion (Sun) orbit overlay
    if (e.code === "KeyO") {
      showSunOrbit = !showSunOrbit;
      state.message = "Sun orbit overlay: " + (showSunOrbit ? "ON" : "OFF");
    }

    if (e.code === "KeyH") {
      setHelpVisible(!helpVisible);
    }

    if (e.code === "Digit1") setTransferTarget(1);
    if (e.code === "Digit2") setTransferTarget(2);
    if (e.code === "Digit3") setTransferTarget(3);
    if (e.code === "Digit4") setTransferTarget(4);
    if (e.code === "Digit5") setTransferTarget(5);
    if (e.code === "Digit6") setTransferTarget(6);
    if (e.code === "Digit7") setTransferTarget(7);
    if (e.code === "Digit8") setTransferTarget(8);

    if (e.code === "KeyP") {
      createTransferPlan();
    }
  });

  window.addEventListener("keyup", e => {
    keys[e.code] = false;
  });

  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    if (e.deltaY < 0) {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * ZOOM_STEP_MOUSE);
    } else if (e.deltaY > 0) {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / ZOOM_STEP_MOUSE);
    }
  }, { passive: false });


if (helpToggle) {
  helpToggle.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    setHelpVisible(!helpVisible);
  });
}
if (diffEasyBtn) {
  diffEasyBtn.addEventListener("click", function (e) {
    e.preventDefault();
    e.stopPropagation();
    setDifficultyMode("easy");
  });
}
if (diffHardBtn) {
  diffHardBtn.addEventListener("click", function (e) {
    e.preventDefault();
    e.stopPropagation();
    setDifficultyMode("hard");
  });
}

  
  function getScale() {
    const w = canvas.width;
    const h = canvas.height;
    const baseScale = Math.min(w, h) / (SYSTEM_RADIUS * 2);
    return baseScale * cameraZoom;
  }

  canvas.addEventListener("mousedown", e => {
    if (e.button !== 0) return;
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartCamX = cameraX;
    dragStartCamY = cameraY;
    cameraFollow = false;
    state.message = "Camera: free (drag to pan)";
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
  });

  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    const scale = getScale();
    cameraX = dragStartCamX - dx / scale;
    cameraY = dragStartCamY + dy / scale;
  });

  function stageSeparation() {
    if (state.crashed || state.escaped) return;
    if (state.currentStageIndex >= state.stages.length - 1) return;
    state.currentStageIndex++;
    state.message = "Stage separated!";
  }

  // --- Physics step ------------------------------------------------------
  function update(dt) {
    state.time += dt;
    updateBodyPositions(dt);

    const rocket = state.rocket;
    const stage = currentStage();
    if (!rocket) return;

    const spinFactor = getSpinFactor();

    if (state.landed && !state.crashed && !state.escaped) {
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        rocket.angle += ROT_SPEED * dt * spinFactor;
      }
      if (keys["ArrowRight"] || keys["KeyD"]) {
        rocket.angle -= ROT_SPEED * dt * spinFactor;
      }

      const body = state.landedBody || getPrimaryBody(rocket.x, rocket.y);
      state.landedBody = body;

      let bodyVx = 0;
      let bodyVy = 0;
      if (typeof body.orbitalRadius === "number") {
        const rOrbit = body.orbitalRadius;
        const omega = body.orbitalSpeed;
        const angle = body.angle;
        bodyVx = -Math.sin(angle) * rOrbit * omega;
        bodyVy =  Math.cos(angle) * rOrbit * omega;
      }

      const alt = state.landedAltitude != null ? state.landedAltitude : body.radius;
      const normalAngle =
        state.landedNormalAngle != null
          ? state.landedNormalAngle
          : Math.atan2(rocket.y - body.y, rocket.x - body.x);

      rocket.x = body.x + Math.cos(normalAngle) * alt;
      rocket.y = body.y + Math.sin(normalAngle) * alt;
      rocket.vx = bodyVx;
      rocket.vy = bodyVy;

      const wantsThrust = stage && stage.fuel > 0 && (keys["ArrowUp"] || keys["KeyW"]);
      rocket.thrusting = !!wantsThrust;

      if (cameraFollow) {
        cameraX = rocket.x;
        cameraY = rocket.y;
      }

           if (!wantsThrust) {
        return;
      } else {
        state.landed = false;
        state.landedBody = null;
        state.message = "Liftoff from " + body.name + "!";

        // Once we leave the pad, fade out the difficulty selector
        hideDifficultyPanel();
      }

    }

    if (state.crashed || state.escaped) {
      rocket.thrusting = false;
      return;
    }

    if (keys["ArrowLeft"] || keys["KeyA"]) {
      rocket.angle += ROT_SPEED * dt * spinFactor;
    }
    if (keys["ArrowRight"] || keys["KeyD"]) {
      rocket.angle -= ROT_SPEED * dt * spinFactor;
    }

    if (stage && stage.fuel > 0) {
      rocket.thrusting = (keys["ArrowUp"] || keys["KeyW"]);
    } else {
      rocket.thrusting = false;
    }

        let ax = 0;
    let ay = 0;

    // 1) Find the strongest gravitational pull at the rocket's position
    let dominantAccMag = 0;
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= 1e-3) continue; // avoid divide-by-zero if we're basically at the center
      const gMag = body.mu / (r * r);
      if (!isFinite(gMag)) continue;
      if (gMag > dominantAccMag) dominantAccMag = gMag;
    }

    // 2) Apply gravity only from bodies that matter (>= a few % of dominant)
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= 1e-3) continue;

      const gMag = body.mu / (r * r);
      if (!isFinite(gMag)) continue;

      // If this body's pull is tiny compared to the dominant one, ignore it
      if (dominantAccMag > 0 && gMag < dominantAccMag * GRAV_PERTURB_THRESHOLD) {
        continue;
      }

      const gravAccMag = -gMag;
      ax += gravAccMag * (dx / r);
      ay += gravAccMag * (dy / r);
    }


    if (rocket.thrusting && stage && stage.fuel > 0) {
      const mass = rocketMass();
      const thrustAcc = stage.thrust / mass;
      const tx = Math.cos(rocket.angle) * thrustAcc;
      const ty = Math.sin(rocket.angle) * thrustAcc;
      ax += tx;
      ay += ty;

      const fuelUseRate = 25;
      const dfuel = fuelUseRate * dt;
      stage.fuel = Math.max(0, stage.fuel - dfuel);
      if (stage.fuel <= 0) {
        rocket.thrusting = false;
        state.message = stage.name + " out of fuel.";
      }
    }

    rocket.vx += ax * dt;
    rocket.vy += ay * dt;
    rocket.x += rocket.vx * dt;
    rocket.y += rocket.vy * dt;

    if (state.time % 0.02 < dt) {
      state.trail.push({ x: rocket.x, y: rocket.y });
      if (state.trail.length > 500) {
        state.trail.shift();
      }
    }

    let collidedBody = null;
    let minDist = Infinity;
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= body.radius && r < minDist) {
        minDist = r;
        collidedBody = body;
      }
    }

    const speed = Math.hypot(rocket.vx, rocket.vy);

    if (collidedBody) {
      if (collidedBody === SUN || speed >= 3) {
        state.crashed = true;
        state.message = "CRASH into " + collidedBody.name + "! Press R to retry.";
        return;
      } else {
        state.landed = true;
        state.landedBody = collidedBody;
        state.landedAltitude = collidedBody.radius;
        state.landedNormalAngle = Math.atan2(rocket.y - collidedBody.y, rocket.x - collidedBody.x);
        rocket.vx = 0;
        rocket.vy = 0;
        state.message = "Nice landing on " + collidedBody.name + "! Hold ↑ to take off or R to reset.";
        return;
      }
    }

    classifyOrbit();

    if (cameraFollow) {
      cameraX = rocket.x;
      cameraY = rocket.y;
    }
  }

  // --- Orbit classification ----------------------------------------------
  function classifyOrbit() {
    const rocket = state.rocket;
    const body = getPrimaryBody(rocket.x, rocket.y);
    state.primaryBody = body;

    const rx = rocket.x - body.x;
    const ry = rocket.y - body.y;
    const r = Math.hypot(rx, ry);

    let bodyVx = 0;
    let bodyVy = 0;
    if (typeof body.orbitalRadius === "number") {
      const rOrbit = body.orbitalRadius;
      const omega = body.orbitalSpeed;
      const angle = body.angle;
      bodyVx = -Math.sin(angle) * rOrbit * omega;
      bodyVy =  Math.cos(angle) * rOrbit * omega;
    }

    const vxRel = rocket.vx - bodyVx;
    const vyRel = rocket.vy - bodyVy;
    const v2 = vxRel * vxRel + vyRel * vyRel;
    const mu = body.mu;

    const specificEnergy = 0.5 * v2 - mu / r;

    state.orbitStable = false;
    state.orbitBound = false;
    state.orbitEscaping = false;
    state.orbitPeriod = null;
    state.orbitElements = null;

    if (specificEnergy > 0) {
      state.orbitEscaping = true;
      state.lastPeriapsis = null;
    } else if (specificEnergy < 0) {
      state.orbitBound = true;

      const h = rx * vyRel - ry * vxRel;
      const a = -mu / (2 * specificEnergy);
      let e2 = 1 - (h * h) / (a * mu);
      if (e2 < 0) e2 = 0;
      const e = Math.sqrt(e2);
      const rp = a * (1 - e);

      state.lastPeriapsis = rp - body.radius;
      state.orbitPeriod = 2 * Math.PI * Math.sqrt(Math.pow(a, 3) / mu);

      if (isFinite(a) && e >= 0) {
        const rdotv = rx * vxRel + ry * vyRel;
        const factor1 = (v2 - mu / r) / mu;
        const factor2 = rdotv / mu;

        let ex = factor1 * rx - factor2 * vxRel;
        let ey = factor1 * ry - factor2 * vyRel;
        let emag = Math.hypot(ex, ey);

        if (emag < 1e-6) {
          ex = rx / r;
          ey = ry / r;
          emag = 1;
        }

        const ehatx = ex / emag;
        const ehaty = ey / emag;

        const rpRadius = a * (1 - e);
        const raRadius = a * (1 + e);

        const periX = body.x + ehatx * rpRadius;
        const periY = body.y + ehaty * rpRadius;
        const apoX  = body.x - ehatx * raRadius;
        const apoY  = body.y - ehaty * raRadius;

        state.orbitElements = {
          bodyName: body.name,
          bodyX: body.x,
          bodyY: body.y,
          periRadius: rpRadius,
          apoRadius: raRadius,
          periX,
          periY,
          apoX,
          apoY
        };
      }

      const atmo = body.atmosphere || 0;
      if (rp > body.radius + atmo) {
        state.orbitStable = true;
        if (!state.message.startsWith("Stable orbit around")) {
          state.message = "Stable orbit around " + body.name + " achieved!";
        }
      }
       } else {
      state.lastPeriapsis = null;
    }

    // --- Helion (Sun)-centric orbit for overlay ------------------------
    {
      const sx = rocket.x - SUN.x;
      const sy = rocket.y - SUN.y;
      const rSun = Math.hypot(sx, sy);
      const vxSun = rocket.vx;
      const vySun = rocket.vy;
      const muSun = SUN.mu;

      const v2Sun = vxSun * vxSun + vySun * vySun;
      const epsSun = 0.5 * v2Sun - muSun / rSun;

      state.sunOrbitBound = false;
      state.sunOrbitElements = null;

      if (epsSun < 0) {
        const hSun = sx * vySun - sy * vxSun;
        const aSun = -muSun / (2 * epsSun);
        let e2Sun = 1 - (hSun * hSun) / (aSun * muSun);
        if (e2Sun < 0) e2Sun = 0;
        const eSun = Math.sqrt(e2Sun);
        const rpSun = aSun * (1 - eSun);
        const raSun = aSun * (1 + eSun);

        if (isFinite(aSun) && eSun >= 0) {
          const rdotvSun = sx * vxSun + sy * vySun;
          const factor1 = (v2Sun - muSun / rSun) / muSun;
          const factor2 = rdotvSun / muSun;

          let exSun = factor1 * sx - factor2 * vxSun;
          let eySun = factor1 * sy - factor2 * vySun;
          let emagSun = Math.hypot(exSun, eySun);
          if (emagSun < 1e-6) {
            exSun = sx / rSun;
            eySun = sy / rSun;
            emagSun = 1;
          }

          const ehatxSun = exSun / emagSun;
          const ehatySun = eySun / emagSun;

          const periXSun = SUN.x + ehatxSun * rpSun;
          const periYSun = SUN.y + ehatySun * rpSun;
          const apoXSun  = SUN.x - ehatxSun * raSun;
          const apoYSun  = SUN.y - ehatySun * raSun;

          state.sunOrbitBound = true;
          state.sunOrbitElements = {
            bodyName: SUN.name,
            bodyX: SUN.x,
            bodyY: SUN.y,
            periRadius: rpSun,
            apoRadius: raSun,
            periX: periXSun,
            periY: periYSun,
            apoX: apoXSun,
            apoY: apoYSun
          };
        }
      }
    }

    // System escape check
    const distFromOrigin = Math.hypot(rocket.x, rocket.y);
    if (!state.escaped && distFromOrigin > SYSTEM_ESCAPE_RADIUS) {
      state.escaped = true;
      state.message = "You escaped the system! Press R to restart.";
    }
  }


  // --- Hohmann transfer planner -----------------------------------------
  function createTransferPlan() {
    const rocket = state.rocket;
    if (!rocket) return;

    const origin = state.primaryBody || getPrimaryBody(rocket.x, rocket.y);
    const originIndex = BODIES.indexOf(origin);
    const destIndex = transferTargetIndex;

    if (originIndex <= 0 || destIndex <= 0) {
      state.message = "Planner: origin and destination must be planets (not Helion).";
      transferPlan = null;
      return;
    }

    const dest = BODIES[destIndex];

    if (typeof origin.orbitalRadius !== "number" || typeof dest.orbitalRadius !== "number") {
      state.message = "Planner: both bodies must orbit Helion.";
      transferPlan = null;
      return;
    }

    const r1 = origin.orbitalRadius;
    const r2 = dest.orbitalRadius;

    if (r2 <= r1) {
      state.message = "Planner: only inner → outer Hohmann supported.";
      transferPlan = null;
      return;
    }

    const mu = SUN.mu;

    const a_t = (r1 + r2) / 2;
    const tTransfer = Math.PI * Math.sqrt((a_t * a_t * a_t) / mu);

    const v1 = Math.sqrt(mu / r1);
    const v2 = Math.sqrt(mu / r2);

    const vTrans1 = Math.sqrt(mu * (2 / r1 - 1 / a_t));
    const vTrans2 = Math.sqrt(mu * (2 / r2 - 1 / a_t));

    const deltaV1 = vTrans1 - v1;
    const deltaV2 = v2 - vTrans2;

    const omegaOrigin = origin.orbitalSpeed;
    const omegaDest = dest.orbitalSpeed;

    const phaseTarget = normalizeAngle(Math.PI - omegaDest * tTransfer);
    const periAngle = origin.angle;

    transferPlan = {
      originIndex,
      destIndex,
      r1,
      r2,
      a_t,
      tTransfer,
      deltaV1,
      deltaV2,
      phaseTarget,
      periAngle,
      omegaOrigin,
      omegaDest
    };

    state.message = "Planner: Hohmann " + origin.name + " → " + dest.name + " created. Burn when phase error ≈ 0°.";
  }

  // --- Predictive path ---------------------------------------------------
  function updatePredictedPath() {
    const rocket = state.rocket;
    if (!rocket || state.crashed || state.landed) {
      state.predictedPath = [];
      return;
    }

    let x = rocket.x;
    let y = rocket.y;
    let vx = rocket.vx;
    let vy = rocket.vy;

    const predicted = [];

    // Longer horizon + slightly larger max radius to match blown-up system.
    const dt = 0.1;
    const steps = 10000;                 // 10000 * 0.1 = 1000 seconds
    const maxRadius = SYSTEM_ESCAPE_RADIUS * 3;

    const predBodies = BODIES.map(b => ({
      name: b.name,
      x: b.x,
      y: b.y,
      radius: b.radius,
      mu: b.mu,
      atmosphere: b.atmosphere || 0,
      orbitalRadius: b.orbitalRadius,
      angle: b.angle,
      orbitalSpeed: b.orbitalSpeed
    }));

    const predSun = predBodies[0];

    for (let i = 0; i < steps; i++) {
      for (let j = 1; j < predBodies.length; j++) {
        const pb = predBodies[j];
        if (typeof pb.orbitalRadius === "number" && typeof pb.orbitalSpeed === "number") {
          pb.angle += pb.orbitalSpeed * dt;
          pb.x = predSun.x + Math.cos(pb.angle) * pb.orbitalRadius;
          pb.y = predSun.y + Math.sin(pb.angle) * pb.orbitalRadius;
        }
      }

      let hit = false;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= body.radius) {
          hit = true;
          break;
        }
      }
      if (hit) break;

      const distFromOrigin = Math.hypot(x, y);
      if (distFromOrigin > maxRadius) break;

            let ax = 0;
      let ay = 0;

      // 1) Dominant gravity at the predicted position
      let dominantAccMag = 0;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= 1e-3) continue;
        const gMag = body.mu / (r * r);
        if (!isFinite(gMag)) continue;
        if (gMag > dominantAccMag) dominantAccMag = gMag;
      }

      // 2) Apply only significant contributors
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= 1e-3) continue;

        const gMag = body.mu / (r * r);
        if (!isFinite(gMag)) continue;

        if (dominantAccMag > 0 && gMag < dominantAccMag * GRAV_PERTURB_THRESHOLD) {
          continue;
        }

        const gravAccMag = -gMag;
        ax += gravAccMag * (dx / r);
        ay += gravAccMag * (dy / r);
      }

      vx += ax * dt;
      vy += ay * dt;

      x += vx * dt;
      y += vy * dt;

      if (i % 8 === 0) {
        predicted.push({ x, y });
      }
    }

    state.predictedPath = predicted;
  }

  // --- Drawing -----------------------------------------------------------
  function draw() {
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const scale = getScale();
    const centerX = w / 2;
    const centerY = h / 2;

    function worldToScreen(x, y) {
      return {
        x: centerX + (x - cameraX) * scale,
        y: centerY - (y - cameraY) * scale
      };
    }

    function screenWithinBounds(p) {
      return (
        p.x > -SAFE_COORD && p.x < SAFE_COORD &&
        p.y > -SAFE_COORD && p.y < SAFE_COORD
      );
    }

    // --- Starfield background -------------------------------------------
        // --- Starfield background -------------------------------------------
    ctx.save();
    // Smaller stars overall; they grow slightly as you zoom in, but stay tiny when zoomed out
    const baseStarSize = 0.45 + 0.18 * Math.log10(1 + cameraZoom); // ~0.45 → ~1px typical
    for (const s of STARS) {
      const p = worldToScreen(s.x, s.y);
      if (p.x < -50 || p.x > w + 50 || p.y < -50 || p.y > h + 50) continue;

      const alpha = 0.25 + s.brightness * 0.6;
      const r = baseStarSize * (0.6 + 0.8 * s.size); // keep variety but keep them small

      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
    }
    ctx.restore();


    // Orbital paths (Helion-centered dashed circles)
    ctx.save();
    ctx.strokeStyle = "rgba(255, 255, 255, 0.12)";
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 6]);

    const sunScreen = worldToScreen(SUN.x, SUN.y);
    const maxOrbitScreenRadius = Math.max(w, h) * 1.2;

    for (const body of BODIES) {
      if (typeof body.orbitalRadius === "number") {
        const rPx = body.orbitalRadius * scale;
        if (rPx < 1 || rPx > SAFE_ORBIT_RADIUS_PX || rPx > maxOrbitScreenRadius) continue;
        ctx.beginPath();
        ctx.arc(sunScreen.x, sunScreen.y, rPx, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    ctx.restore();

    // Hohmann transfer orbit (if any)
    if (transferPlan) {
      const { r1, r2, a_t, periAngle } = transferPlan;
      const maxR = Math.max(r1, r2);
      const maxRPx = maxR * scale;
      const maxTransferRadius = Math.max(w, h) * 1.2;

      if (maxRPx < SAFE_ORBIT_RADIUS_PX && maxRPx < maxTransferRadius) {
        const eTran = (r2 - r1) / (r2 + r1);

        ctx.save();
        ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 120;
        for (let i = 0; i <= steps; i++) {
          const f = (Math.PI * i) / steps;
          const r = a_t * (1 - eTran * eTran) / (1 + eTran * Math.cos(f));
          const theta = periAngle + f;

          const x = SUN.x + r * Math.cos(theta);
          const y = SUN.y + r * Math.sin(theta);

          const p = worldToScreen(x, y);
          const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      }
    }

         // Bodies: Helion + planets
    for (const body of BODIES) {
      ctx.save();
      const screen = worldToScreen(body.x, body.y);
      const rPx = body.radius * scale;

      // Icon mode when zoomed way out so planets stay visible
      const MIN_ICON_RADIUS = 3;
      const useIcon = rPx < MIN_ICON_RADIUS * 2;
      const drawRadius = useIcon
        ? (body === SUN ? MIN_ICON_RADIUS * 2.5 : MIN_ICON_RADIUS)
        : rPx;


      // Culling based on what we'll actually draw
      const margin = Math.max(w, h) * 0.6 + drawRadius;
      if (screen.x < -margin || screen.x > w + margin ||
          screen.y < -margin || screen.y > h + margin) {
        ctx.restore();
        continue;
      }

      if (useIcon) {
        // Tiny map-style dot, lightly colored
        const midColor = (body.colors && body.colors.mid) || "#ffffff";
        ctx.fillStyle = (body === SUN) ? "#ffd080" : midColor;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, drawRadius, 0, Math.PI * 2);
        ctx.fill();
      } else {
        const c = body.colors;
        const planetRadius = drawRadius;

        // Base disc with soft lighting
        const coreGradient = ctx.createRadialGradient(
          screen.x - planetRadius * 0.35,
          screen.y - planetRadius * 0.35,
          planetRadius * 0.2,
          screen.x,
          screen.y,
          planetRadius
        );
        coreGradient.addColorStop(0, c.inner);
        coreGradient.addColorStop(0.5, c.mid);
        coreGradient.addColorStop(1, c.outer);

        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, planetRadius, 0, Math.PI * 2);
        ctx.fill();

        // Rim light / specular highlight
        const rimGrad = ctx.createRadialGradient(
          screen.x + planetRadius * 0.2,
          screen.y - planetRadius * 0.4,
          planetRadius * 0.6,
          screen.x,
          screen.y,
          planetRadius * 1.3
        );
        rimGrad.addColorStop(0, "rgba(255,255,255,0.35)");
        rimGrad.addColorStop(0.4, "rgba(255,255,255,0.10)");
        rimGrad.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = rimGrad;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, planetRadius, 0, Math.PI * 2);
        ctx.fill();

        // Special banding for gas/ice giants
        if (body.name === "Zephyrus" || body.name === "Noxshade") {
          ctx.save();
          // Clip to planet disc
          ctx.beginPath();
          ctx.arc(screen.x, screen.y, planetRadius, 0, Math.PI * 2);
          ctx.clip();

          const bandCount = 6;
          for (let i = 0; i < bandCount; i++) {
            const t = i / (bandCount - 1);
            const y = screen.y - planetRadius + t * 2 * planetRadius;

            const bandGrad = ctx.createLinearGradient(
              screen.x - planetRadius, y,
              screen.x + planetRadius, y
            );
            const base = body.colors.mid;
            bandGrad.addColorStop(0, base);
            bandGrad.addColorStop(0.5, "rgba(255,255,255,0.18)");
            bandGrad.addColorStop(1, base);

            ctx.fillStyle = bandGrad;
            ctx.globalAlpha = 0.16 + 0.08 * Math.sin(t * Math.PI);
            ctx.fillRect(
              screen.x - planetRadius,
              y - planetRadius / bandCount,
              planetRadius * 2,
              (2 * planetRadius) / bandCount
            );
          }
          ctx.restore();
          ctx.globalAlpha = 1;
        }

        // Thin atmospheric glow if present
        const atmo = body.atmosphere || 0;
        if (atmo > 0) {
          const atmoRadiusPx = (body.radius + atmo) * scale;
          if (atmoRadiusPx < SAFE_ORBIT_RADIUS_PX) {
            const atmoGrad = ctx.createRadialGradient(
              screen.x,
              screen.y,
              planetRadius,
              screen.x,
              screen.y,
              atmoRadiusPx
            );
            atmoGrad.addColorStop(0, "rgba(135,206,255,0.0)");
            atmoGrad.addColorStop(1, "rgba(135,206,255,0.35)");

            ctx.strokeStyle = atmoGrad;
            ctx.lineWidth = Math.max(1, atmoRadiusPx - planetRadius);
            ctx.beginPath();
            ctx.arc(
              screen.x,
              screen.y,
              (planetRadius + atmoRadiusPx) / 2,
              0,
              Math.PI * 2
            );
            ctx.stroke();
          }
        }
      }

      // Labels – hide when super zoomed-out icon mode to avoid clutter
      if (!useIcon || cameraZoom > 0.4) {
        ctx.fillStyle = "#ffffff";
        ctx.font = "11px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText(body.name, screen.x, screen.y + drawRadius + 4);
      }

      ctx.restore();
    }



    // Predicted trajectory (thicker + visible across zoom levels)
    if (state.predictedPath && state.predictedPath.length > 1) {
      ctx.save();
      ctx.setLineDash([6, 4]);
      ctx.lineWidth = Math.max(1, Math.min(3, cameraZoom * 0.15));
      ctx.strokeStyle = "rgba(255, 255, 0, 0.9)";
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.predictedPath.length; i++) {
        const p = worldToScreen(state.predictedPath[i].x, state.predictedPath[i].y);
        const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Trail
    if (state.trail.length > 1) {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(180,180,255,0.6)";
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.trail.length; i++) {
        const p = worldToScreen(state.trail[i].x, state.trail[i].y);
        const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Apsis markers + analytic orbit ellipse for current bound orbit
    if (state.orbitBound && state.orbitElements) {
      const oe = state.orbitElements;

      const periScreen = worldToScreen(oe.periX, oe.periY);
      const apoScreen  = worldToScreen(oe.apoX, oe.apoY);
      const bodyScreen = worldToScreen(oe.bodyX, oe.bodyY);

      (function drawOrbitEllipse() {
        const rp = oe.periRadius;
        const ra = oe.apoRadius;
        const a  = (rp + ra) / 2;
        if (!isFinite(a) || a <= 0) return;

        let e = 1 - rp / a;
        if (!isFinite(e) || e < 0) e = 0;
        if (e > 0.999) e = 0.999;

        const maxR = ra;
        const maxRPx = maxR * scale;
        if (maxRPx < 1 || maxRPx > SAFE_ORBIT_RADIUS_PX) return;

        let px = oe.periX - oe.bodyX;
        let py = oe.periY - oe.bodyY;
        let plen = Math.hypot(px, py);
        if (plen < 1e-6) return;

        const pHatX = px / plen;
        const pHatY = py / plen;
        const qHatX = -pHatY;
        const qHatY =  pHatX;

        ctx.save();
        ctx.strokeStyle = "rgba(80,180,255,0.9)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 240;
        for (let i = 0; i <= steps; i++) {
          const f = (2 * Math.PI * i) / steps;
          const r = a * (1 - e * e) / (1 + e * Math.cos(f));
          if (!isFinite(r) || r <= 0) continue;

          const cosf = Math.cos(f);
          const sinf = Math.sin(f);

          const worldX =
            oe.bodyX + r * (cosf * pHatX + sinf * qHatX);
          const worldY =
            oe.bodyY + r * (cosf * pHatY + sinf * qHatY);

          const p = worldToScreen(worldX, worldY);
          const onScreen =
            p.x >= -50 && p.x <= w + 50 &&
            p.y >= -50 && p.y <= h + 50;

          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      })();

      if (screenWithinBounds(periScreen) || screenWithinBounds(apoScreen) || screenWithinBounds(bodyScreen)) {
        ctx.save();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;

        ctx.strokeStyle = "rgba(0,255,136,0.5)";
        ctx.beginPath();
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(periScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(periScreen.x, periScreen.y);
        }
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(apoScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(apoScreen.x, apoScreen.y);
        }
        ctx.stroke();

        if (screenWithinBounds(periScreen)) {
          ctx.fillStyle = "#00ff88";
          ctx.beginPath();
          ctx.arc(periScreen.x, periScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#00ff88";
          ctx.fillText("Pe", periScreen.x + 6, periScreen.y - 2);
        }

        if (screenWithinBounds(apoScreen)) {
          ctx.fillStyle = "#ff66ff";
          ctx.beginPath();
          ctx.arc(apoScreen.x, apoScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#ff66ff";
          ctx.fillText("Ap", apoScreen.x + 6, apoScreen.y - 2);
        }

        ctx.restore();
      }
    }

        // Sun-centric (Helion) orbit ellipse + Pe/Ap overlay (toggleable)
    if (showSunOrbit && state.sunOrbitBound && state.sunOrbitElements && state.primaryBody !== SUN) {
      const oeS = state.sunOrbitElements;

      const periScreenS = worldToScreen(oeS.periX, oeS.periY);
      const apoScreenS  = worldToScreen(oeS.apoX, oeS.apoY);
      const bodyScreenS = worldToScreen(oeS.bodyX, oeS.bodyY);

      (function drawSunOrbitEllipse() {
        const rpS = oeS.periRadius;
        const raS = oeS.apoRadius;
        const aS  = (rpS + raS) / 2;
        if (!isFinite(aS) || aS <= 0) return;

        let eS = 1 - rpS / aS;
        if (!isFinite(eS) || eS < 0) eS = 0;
        if (eS > 0.999) eS = 0.999;

        const maxR = raS;
        const maxRPx = maxR * scale;
        if (maxRPx < 1 || maxRPx > SAFE_ORBIT_RADIUS_PX) return;

        let pxS = oeS.periX - oeS.bodyX;
        let pyS = oeS.periY - oeS.bodyY;
        let plenS = Math.hypot(pxS, pyS);
        if (plenS < 1e-6) return;

        const pHatXS = pxS / plenS;
        const pHatYS = pyS / plenS;
        const qHatXS = -pHatYS;
        const qHatYS =  pHatXS;

        ctx.save();
        ctx.strokeStyle = "rgba(0,255,200,0.8)"; // cyan-ish for Helion orbit
        ctx.lineWidth = 1;
        ctx.setLineDash([6, 3]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 260;
        for (let i = 0; i <= steps; i++) {
          const f = (2 * Math.PI * i) / steps;
          const r = aS * (1 - eS * eS) / (1 + eS * Math.cos(f));
          if (!isFinite(r) || r <= 0) continue;

          const cosf = Math.cos(f);
          const sinf = Math.sin(f);

          const worldX =
            oeS.bodyX + r * (cosf * pHatXS + sinf * qHatXS);
          const worldY =
            oeS.bodyY + r * (cosf * pHatYS + sinf * qHatYS);

          const p = worldToScreen(worldX, worldY);
          const onScreen =
            p.x >= -50 && p.x <= w + 50 &&
            p.y >= -50 && p.y <= h + 50;

          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      })();

      if (screenWithinBounds(periScreenS) || screenWithinBounds(apoScreenS) || screenWithinBounds(bodyScreenS)) {
        ctx.save();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;

        // Lines from Helion to Sun Pe/Ap
        ctx.strokeStyle = "rgba(0,255,200,0.4)";
        ctx.beginPath();
        if (screenWithinBounds(bodyScreenS) && screenWithinBounds(periScreenS)) {
          ctx.moveTo(bodyScreenS.x, bodyScreenS.y);
          ctx.lineTo(periScreenS.x, periScreenS.y);
        }
        if (screenWithinBounds(bodyScreenS) && screenWithinBounds(apoScreenS)) {
          ctx.moveTo(bodyScreenS.x, bodyScreenS.y);
          ctx.lineTo(apoScreenS.x, apoScreenS.y);
        }
        ctx.stroke();

        // Periapsis marker (Sun)
        if (screenWithinBounds(periScreenS)) {
          ctx.fillStyle = "#00ffd5";
          ctx.beginPath();
          ctx.arc(periScreenS.x, periScreenS.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillText("Pe☉", periScreenS.x + 6, periScreenS.y - 2);
        }

        // Apoapsis marker (Sun)
        if (screenWithinBounds(apoScreenS)) {
          ctx.fillStyle = "#ff99ff";
          ctx.beginPath();
          ctx.arc(apoScreenS.x, apoScreenS.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillText("Ap☉", apoScreenS.x + 6, apoScreenS.y - 2);
        }

        ctx.restore();
      }
    }


    // Rocket
    const rocket = state.rocket;
    const rocketScreen = worldToScreen(rocket.x, rocket.y);

    ctx.save();
    ctx.translate(rocketScreen.x, rocketScreen.y);
    ctx.rotate(-rocket.angle + Math.PI / 2);

    const bodyWidth = 6;
    const bodyHeight = 20;

    const stageIndex = state.currentStageIndex;
    const colors = ["#dddddd", "#ffcc66", "#99ccff"];
    const bodyColor = colors[Math.min(colors.length - 1, stageIndex + 1)];

    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.7);
    ctx.lineTo(bodyWidth / 2, bodyHeight * 0.3);
    ctx.lineTo(0, bodyHeight * 0.5);
    ctx.lineTo(-bodyWidth / 2, bodyHeight * 0.3);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.9);
    ctx.lineTo(bodyWidth / 2, -bodyHeight * 0.7);
    ctx.lineTo(-bodyWidth / 2, -bodyHeight * 0.7);
    ctx.closePath();
    ctx.fill();

    if (rocket.thrusting && !state.crashed && !state.landed) {
      ctx.fillStyle = "#ff9933";
      ctx.beginPath();
      ctx.moveTo(0, bodyHeight * 0.5);
      ctx.lineTo(bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.lineTo(-bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

        // HUD (digital steampunk)

    const primary = state.primaryBody || getPrimaryBody(rocket.x, rocket.y);
    const dxp = rocket.x - primary.x;
    const dyp = rocket.y - primary.y;
    const rPrimary = Math.hypot(dxp, dyp);
    const alt = rPrimary - primary.radius;
    const speed = Math.hypot(rocket.vx, rocket.vy);
    const radialVel = (dxp * rocket.vx + dyp * rocket.vy) / rPrimary;

    const stage = currentStage();
    const stageName = stage ? stage.name : "None";
    const fuel = stage ? stage.fuel : 0;
    const maxFuel = stage ? stage.maxFuel : 1;
    const fuelPct = Math.max(0, Math.min(100, (fuel / maxFuel) * 100));

    // New: mass, thrust, TWR, local g, orbit period display
    const mass = rocketMass(); // uses current difficulty's fuel density
    const stageThrust = stage ? stage.thrust : 0; // same units as elsewhere in sim

    // Acceleration from thrust alone (km/s²)
    const thrustAcc = stageThrust > 0 ? stageThrust / mass : 0;
    // Convert to m/s² for display
    const thrustAccMS = thrustAcc * 1000;

    // Local "surface" gravity based on primary's mu and radius (km/s²)
    const surfaceG = primary.mu / (primary.radius * primary.radius);
    const surfaceGms = surfaceG * 1000;

    // Thrust-to-weight ratio relative to local surface gravity
    const twr = surfaceG > 0 ? thrustAcc / surfaceG : 0;

    // Orbit period text (only when bound and period is finite)
    const orbitPeriodText =
      state.orbitPeriod && isFinite(state.orbitPeriod)
        ? (state.orbitPeriod / 60).toFixed(1) + " min"
        : "—";

    let orbitStatus;

    
    if (state.orbitEscaping) {
      orbitStatus = state.escaped ? "Escaped system" : "Escaping " + primary.name;
    } else if (state.orbitStable) {
      orbitStatus = "Stable orbit around " + primary.name;
    } else if (state.orbitBound) {
      orbitStatus = "Bound to " + primary.name + " (reentry)";
    } else {
      orbitStatus = "Suborbital / transitioning";
    }

    const periapsisText =
      state.lastPeriapsis != null
        ? (state.lastPeriapsis >= 0
            ? state.lastPeriapsis.toFixed(1) + " km"
            : "surface")
        : "unknown";

    const apoapsisText =
      state.orbitElements && state.orbitBound
        ? (state.orbitElements.apoRadius - primary.radius).toFixed(1) + " km"
        : "unknown";

    const camModeText = cameraFollow ? "Follow ship" : "Free";

    // Normalized values for gauges
    const warpNorm = (() => {
      const minLog = Math.log10(MIN_WARP);
      const maxLog = Math.log10(MAX_WARP);
      const wLog = Math.log10(Math.max(MIN_WARP, Math.min(MAX_WARP, timeScale)));
      return (wLog - minLog) / (maxLog - minLog);
    })();

    const zoomNorm = (() => {
      const z = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom));
      const minLog = Math.log10(MIN_ZOOM);
      const maxLog = Math.log10(MAX_ZOOM);
      const zLog   = Math.log10(z);
      const denom  = maxLog - minLog || 1;
      const t = (zLog - minLog) / denom;
      return Math.max(0, Math.min(1, t));
    })();


    const zoomDisplayText = (() => {
      const z = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom));

      // Tiny to moderate zoom:
      if (z < 10)  return z.toFixed(2) + "x";
      if (z < 100) return z.toFixed(1) + "x";
      if (z < 1000) return z.toFixed(0) + "x";

      // Large zoom: switch to scientific notation so it doesn't overflow the chip
      return z.toExponential(2) + "x";
    })();

    

    // Transfer planner HUD chunk
    let transferHTML = "";
    if (transferPlan) {
      const origin = BODIES[transferPlan.originIndex];
      const dest = BODIES[transferPlan.destIndex];

      const currentPhase = normalizeAngle(dest.angle - origin.angle);
      const phaseErrorRad = smallestAngleDiff(transferPlan.phaseTarget, currentPhase);
      const phaseErrorDeg = phaseErrorRad * 180 / Math.PI;

      const relOmega = transferPlan.omegaDest - transferPlan.omegaOrigin;
      let timeToWindow = null;
      if (Math.abs(relOmega) > 1e-8) {
        let tRaw = phaseErrorRad / relOmega;
        const synodicPeriod = 2 * Math.PI / Math.abs(relOmega);
        tRaw = ((tRaw % synodicPeriod) + synodicPeriod) % synodicPeriod;
        timeToWindow = tRaw;
      }

      const timeStr =
        timeToWindow != null
          ? ` · T-${(timeToWindow / 60).toFixed(1)} min`
          : "";

      transferHTML = `
        <div class="hud-chip hud-chip--wide">
          <span class="hud-label">TRANSFER</span>
          <span class="hud-value">
            ${origin.name} → ${dest.name}
          </span>
          <div class="hud-transfer">
            Phase: ${phaseErrorDeg.toFixed(1)}°${timeStr}<br>
            Δv1: ${transferPlan.deltaV1.toFixed(3)} km/s · Δv2: ${transferPlan.deltaV2.toFixed(3)} km/s
          </div>
        </div>
      `;
    }

    const altHTML = odometerHTML(alt, 6, 1);
    const speedHTML = odometerHTML(speed, 4, 2);
    const vspdHTML = odometerHTML(Math.abs(radialVel), 3, 2);

    overlay.innerHTML = `
           <div class="hud-top-row">
        <div class="hud-chip">
          <span class="hud-label">PRIMARY BODY</span>
          <span class="hud-value hud-value--large">${primary.name}</span>
        </div>
        <div class="hud-chip">
          <span class="hud-label">MODE</span>
          <span class="hud-value">
            ${difficulty === "hard" ? "HARD – reduced tanks" : "EASY – full tanks"}
          </span>
        </div>

        <div class="hud-chip">
          <span class="hud-label">ORBIT STATE</span>
          <span class="hud-value">${orbitStatus}</span>
        </div>
        <div class="hud-chip">
          <span class="hud-label">WARP</span>
          <span class="hud-value">${timeScale.toFixed(2)}x</span>
          <div class="hud-bar">
            <div class="hud-bar-fill" style="--pct:${(warpNorm * 100).toFixed(1)}%;"></div>
          </div>
        </div>
        <div class="hud-chip">
          <span class="hud-label">CAMERA</span>
          <span class="hud-value">${camModeText}</span>
        </div>
      </div>
        ${transferHTML
        ? `<div class="hud-top-row hud-top-row--secondary">
             ${transferHTML}
           </div>`
        : ""
      }

            <div class="hud-bottom-panel">
        <!-- Row 1: basic flight -->
        <div class="hud-row">
          <div class="hud-chip">
            <span class="hud-label">ALTITUDE (km)</span>
            <span class="hud-value">${altHTML}</span>
          </div>
          <div class="hud-chip">
            <span class="hud-label">SPEED (km/s)</span>
            <span class="hud-value">${speedHTML}</span>
          </div>
          <div class="hud-chip">
            <span class="hud-label">VERTICAL (km/s)</span>
            <span class="hud-value">
              ${radialVel >= 0 ? "↑" : "↓"} ${vspdHTML}
            </span>
          </div>
        </div>

        <!-- Row 2: orbit geometry + stage -->
        <div class="hud-row">
          <div class="hud-chip">
            <span class="hud-label">PERIAPSIS</span>
            <span class="hud-value">${periapsisText}</span>
          </div>
          <div class="hud-chip">
            <span class="hud-label">APOAPSIS</span>
            <span class="hud-value">${apoapsisText}</span>
          </div>
          <div class="hud-chip">
            <span class="hud-label">STAGE / FUEL</span>
            <span class="hud-value">
              ${stageName} (${fuelPct.toFixed(0)}%) ·
              ${fuel.toFixed(0)}/${maxFuel.toFixed(0)} u
            </span>
            <div class="hud-bar">
              <div class="hud-bar-fill" style="--pct:${fuelPct.toFixed(1)}%;"></div>
            </div>
          </div>
        </div>

        <!-- Row 3: engineering + zoom + transfer -->
        <div class="hud-row">
          <div class="hud-chip">
            <span class="hud-label">MASS</span>
            <span class="hud-value">
              ${mass.toFixed(2)} t
            </span>
          </div>
          <div class="hud-chip">
            <span class="hud-label">LOCAL g</span>
            <span class="hud-value">
              ${surfaceGms.toFixed(2)} m/s²
            </span>
          </div>
          <div class="hud-chip">
            <span class="hud-label">ORBIT PERIOD</span>
            <span class="hud-value">
              ${orbitPeriodText}
            </span>
          </div>
          <div class="hud-chip">
            <span class="hud-label">ZOOM</span>
            <span class="hud-value">${zoomDisplayText}</span>
            <div class="hud-bar">
              <div class="hud-bar-fill" style="--pct:${(zoomNorm * 100).toFixed(1)}%;"></div>
            </div>
            ${typeof zoomScaleText !== "undefined"
              ? `<div class="hud-transfer">Scale: ${zoomScaleText}</div>`
              : ""}
          </div>
        </div>

        <div class="hud-message">${state.message || ""}</div>
      </div>

    `;

  }

    function odometerHTML(value, digits, decimals) {
    const sign = value < 0 ? "-" : "";
    const abs = Math.abs(value);
    const fixed = abs.toFixed(decimals);
    const parts = fixed.split(".");
    const intPart = parts[0].padStart(digits, "0");
    const fracPart = parts[1] || "";

    let html = '<span class="hud-odometer">';

    // Integer digits (with leading zeros dimmed)
    let leadingNonZeroSeen = false;
    for (let i = 0; i < intPart.length; i++) {
      const ch = intPart[i];
      if (ch !== "0") leadingNonZeroSeen = true;
      const dim = !leadingNonZeroSeen && i < intPart.length - 1;
      html += `<span class="hud-odo-digit${dim ? " hud-odo-digit--dim" : ""}">${ch}</span>`;
    }

    // Decimal digits
    if (decimals > 0) {
      html += '<span class="hud-odo-digit">.</span>';
      for (const ch of fracPart) {
        html += `<span class="hud-odo-digit">${ch}</span>`;
      }
    }

    html += "</span>";

    if (sign === "-") {
      html = `<span class="hud-odo-sign">-</span>${html}`;
    }

    return html;
  }




  // --- Main loop ---------------------------------------------------------
// --- Main loop ---------------------------------------------------------
let lastTime = performance.now();
let frameCounter = 0;

function loop(now) {
  frameCounter++;

  const realDt = (now - lastTime) / 1000;
  lastTime = now;

  // How much simulation time we *want* to advance this frame
  let simDt = Math.max(0, realDt * timeScale);

  if (simDt > 0) {
    // Physics stepping:
    //  - Small steps at normal warp for stability
    //  - Much larger steps allowed at huge warp so we don't cap out around 10k×

    const BASE_MAX_STEP = 0.5;     // good for normal flight/orbits
    const HIGH_WARP_MAX_STEP = 8.0; // big chunks at huge warp (orbits still fine)
    const HIGH_WARP_THRESHOLD = 5000; // above this, loosen the step size

    const MAX_STEPS_PER_FRAME = 400; // allow more steps if needed

    // Pick the step size based on current warp
    const maxStep = (timeScale >= HIGH_WARP_THRESHOLD)
      ? HIGH_WARP_MAX_STEP
      : BASE_MAX_STEP;

    // How many steps would we need if every step were maxStep?
    let steps = Math.ceil(simDt / maxStep);

    if (steps > MAX_STEPS_PER_FRAME) {
      // Clamp: we effectively cap simDt to what we can afford this frame,
      // but now the cap is much higher at high warp.
      steps = MAX_STEPS_PER_FRAME;
      simDt = steps * maxStep;
    }

    const stepDt = simDt / steps;

    for (let i = 0; i < steps; i++) {
      update(stepDt);
    }
  }

  // At huge warp, the predicted path is expensive and not very useful.
  // So only update it:
  //  - every frame at low warp
  //  - every Nth frame at high warp
  let shouldUpdatePrediction = true;
  if (timeScale > 2000) {
    // e.g. only recompute 1 out of every 10 frames at high warp
    shouldUpdatePrediction = (frameCounter % 10 === 0);
  }

  if (shouldUpdatePrediction) {
    updatePredictedPath();
  }

  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);


})();
</script>
</body>
</html>
