<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2D Kerbal-Style Orbit Game – Sun & Planets</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    color: #fff;
  }
  #game {
    display: block;
    background: radial-gradient(circle at 50% 130%, #001018, #000000 65%, #02020a);
  }
  #overlay {
    position: fixed;
    top: 8px;
    left: 8px;
    font-size: 14px;
    text-shadow: 0 0 4px #000;
    pointer-events: none;
    white-space: pre;
  }
  #help {
    position: fixed;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    text-shadow: 0 0 4px #000;
    text-align: center;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>
<div id="help">
  Controls: ← → rotate · ↑ thrust / takeoff · SPACE stage · R reset · [ / ] time warp · - / = zoom · F follow/free<br>
  Mouse wheel zooms · Drag to pan (free cam) · Dashed path = coast-only trajectory under moving Sun + planet gravity.
</div>

<script>
(function () {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const SAFE_COORD = 1_000_000;
  const SAFE_ORBIT_RADIUS_PX = 20000;


  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  // --- Time warp ---------------------------------------------------------
  let timeScale = 1;
  const MIN_WARP = 0.1;
  const MAX_WARP = 500;

  // --- Camera: zoom, pan, follow ----------------------------------------
  let cameraZoom = 8;            // higher default to keep planets visible with big system
  const MIN_ZOOM = 0.25;
  const MAX_ZOOM = 1000;         // ⬅ allow ~1000x zoom

  let cameraX = 0;
  let cameraY = 0;
  let cameraFollow = true; // follow ship by default

  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartCamX = 0;
  let dragStartCamY = 0;

  // --- Celestial bodies: Sun + orbiting planets -------------------------
  // Units: x,y,radius in km, mu in km^3 / s^2, atmosphere in km
  // Radii chosen with more realistic ratios (Sun > Kerbette > Duna > Munlet),
  // and mu chosen so surface gravity ratios approximate Sun/Earth/Moon/Mars.
  const BODIES = [
    {
      // Central star
      name: "Sun",
      x: 0,
      y: 0,
      radius: 1200,
      mu: 4.0176e7,       // ~27.9x Kerbette surface gravity
      atmosphere: 0,
      colors: { inner: "#fff7b3", mid: "#ffcc33", outer: "#d47a1a" }
    },
    {
      // Earth-like
      name: "Kerbette",
      orbitalRadius: 15000,   // farther from the Sun
      angle: 0,
      orbitalSpeed: 0,        // set later based on Sun.mu
      x: 0, y: 0,
      radius: 600,
      mu: 3.6e5,              // baseline g
      atmosphere: 40,
      colors: { inner: "#0a3b52", mid: "#0a4f2b", outer: "#021016" }
    },
    {
      // Small gray Moon-like body
      name: "Munlet",
      orbitalRadius: 30000,   // farther out
      angle: Math.PI,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 170,
      mu: 4.7685e3,           // ~0.165x Kerbette surface g
      atmosphere: 0,
      colors: { inner: "#666666", mid: "#999999", outer: "#222222" }
    },
    {
      // Red Mars-like planet
      name: "Duna-ish",
      orbitalRadius: 50000,   // even farther out
      angle: -Math.PI / 2,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 340,
      mu: 4.3928e4,           // ~0.38x Kerbette surface g
      atmosphere: 25,
      colors: { inner: "#5a2610", mid: "#a03c14", outer: "#1e0500" }
    }
  ];

  const SUN = BODIES[0];
  const MAIN_BODY = BODIES[1]; // launch from Kerbette

  // Compute rough system size based on orbital radii
  function computeSystemRadius() {
    let max = 0;
    for (const b of BODIES) {
      let d;
      if (typeof b.orbitalRadius === "number") {
        d = b.orbitalRadius + b.radius * 2;
      } else {
        d = Math.hypot(b.x - SUN.x, b.y - SUN.y) + b.radius * 2;
      }
      if (d > max) max = d;
    }
    return max;
  }

  const SYSTEM_RADIUS = computeSystemRadius();
  const SYSTEM_ESCAPE_RADIUS = SYSTEM_RADIUS * 2.5;

  // Initialize planet orbits (circular, kinematic) around the Sun
  function initOrbits() {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        // Angular speed for circular orbit (scaled for aesthetics)
        body.orbitalSpeed = Math.sqrt(SUN.mu / Math.pow(body.orbitalRadius, 3)) * 0.6;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  function updateBodyPositions(dt) {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        body.angle += body.orbitalSpeed * dt;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  initOrbits();

  function getPrimaryBody(x, y) {
    let best = BODIES[0];
    let bestDist2 = (x - best.x) * (x - best.x) + (y - best.y) * (y - best.y);
    for (let i = 1; i < BODIES.length; i++) {
      const b = BODIES[i];
      const dx = x - b.x;
      const dy = y - b.y;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestDist2) {
        best = b;
        bestDist2 = d2;
      }
    }
    return best;
  }

  // --- Rocket & stages ---------------------------------------------------
  const CORE_MASS = 4;          // tons (arbitrary scaling)
  const FUEL_DENSITY = 0.01;    // tons per unit of fuel

  // Thrust reduced by 20× (slow-burn, low-thrust)
  const STAGES_TEMPLATE = [
    {
      name: "Booster",
      maxFuel: 12000,
      fuel: 12000,
      thrust: 320,   // 3200 / 20
      dryMass: 6
    },
    {
      name: "Orbiter",
      maxFuel: 7000,
      fuel: 7000,
      thrust: 100,    // 1000 / 20
      dryMass: 3
    }
  ];

  const ROT_SPEED = (Math.PI / 180) * 60; // rad/s

  let state;

  function cloneStages() {
    return STAGES_TEMPLATE.map(s => ({ ...s }));
  }

  function resetGame() {
    // Ensure orbits are positioned at reset
    initOrbits();

    const mb = MAIN_BODY;

    // Direction from Sun to planet (radial)
    const dxSun = mb.x - SUN.x;
    const dySun = mb.y - SUN.y;
    const rPlanet = Math.hypot(dxSun, dySun) || 1;
    const ux = dxSun / rPlanet;
    const uy = dySun / rPlanet;

    // Rocket surface position: just above the planet in the radial-out direction
    const surfaceAltitude = mb.radius + 5; // small clearance above surface
    const rocketX = mb.x + ux * surfaceAltitude;
    const rocketY = mb.y + uy * surfaceAltitude;

    // Planet orbital velocity (tangential to radial vector)
    const omega = mb.orbitalSpeed;        // rad/s
    const vMag = omega * rPlanet;         // km/s
    const tx = -uy;                       // tangential direction
    const ty = ux;
    const rocketVx = vMag * tx;
    const rocketVy = vMag * ty;

    // Rocket angle: pointing outward from planet center
    const normalAngle = Math.atan2(rocketY - mb.y, rocketX - mb.x);

    state = {
      rocket: {
        x: rocketX,
        y: rocketY,
        vx: rocketVx,
        vy: rocketVy,
        angle: normalAngle,
        thrusting: false
      },
      stages: cloneStages(),
      currentStageIndex: 0,
      crashed: false,
      landed: true,           // start landed on Kerbette
      landedBody: mb,
      landedAltitude: surfaceAltitude,
      landedNormalAngle: normalAngle,
      escaped: false,
      orbitStable: false,
      orbitBound: false,
      orbitEscaping: false,
      orbitPeriod: null,
      lastPeriapsis: null,
      primaryBody: mb,
      orbitElements: null,
      message: "On Kerbette's surface. Hold ↑ to lift off. Low thrust = long burns.",
      trail: [],
      predictedPath: [],
      time: 0
    };

    cameraFollow = true;
    cameraX = state.rocket.x;
    cameraY = state.rocket.y;
  }

  resetGame();

  function currentStage() {
    return state.stages[state.currentStageIndex] || null;
  }

  function rocketMass() {
    let mass = CORE_MASS;
    for (let i = state.currentStageIndex; i < state.stages.length; i++) {
      const s = state.stages[i];
      mass += s.dryMass + s.fuel * FUEL_DENSITY;
    }
    return mass;
  }

  // --- Input -------------------------------------------------------------
  const keys = {};
  window.addEventListener("keydown", e => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) {
      e.preventDefault();
    }
    keys[e.code] = true;

    if (e.code === "Space") {
      stageSeparation();
    }
    if (e.code === "KeyR") {
      resetGame();
    }

    // Time warp: [ and ]
    if (e.code === "BracketLeft") {
      timeScale = Math.max(MIN_WARP, timeScale / 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }
    if (e.code === "BracketRight") {
      timeScale = Math.min(MAX_WARP, timeScale * 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }

    // Zoom: - and =
    if (e.code === "Minus") {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / 1.2);
    }
    if (e.code === "Equal") {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * 1.2);
    }

    // Camera follow toggle: F
    if (e.code === "KeyF") {
      cameraFollow = !cameraFollow;
      if (cameraFollow) {
        cameraX = state.rocket.x;
        cameraY = state.rocket.y;
        state.message = "Camera: follow ship";
      } else {
        state.message = "Camera: free";
      }
    }
  });

  window.addEventListener("keyup", e => {
    keys[e.code] = false;
  });

  // Mouse wheel zoom
  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    if (e.deltaY < 0) {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * 1.1);
    } else if (e.deltaY > 0) {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / 1.1);
    }
  }, { passive: false });

  function getScale() {
    const w = canvas.width;
    const h = canvas.height;
    const baseScale = Math.min(w, h) / (SYSTEM_RADIUS * 2);
    return baseScale * cameraZoom;
  }

  // Mouse drag pan (free camera)
  canvas.addEventListener("mousedown", e => {
    if (e.button !== 0) return;
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartCamX = cameraX;
    dragStartCamY = cameraY;
    cameraFollow = false;
    state.message = "Camera: free (drag to pan)";
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
  });

  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    const scale = getScale();
    cameraX = dragStartCamX - dx / scale;
    cameraY = dragStartCamY + dy / scale;
  });

  function stageSeparation() {
    if (state.crashed || state.escaped) return;
    if (state.currentStageIndex >= state.stages.length - 1) return;
    state.currentStageIndex++;
    state.message = "Stage separated!";
  }

  // --- Physics step (small dt) ------------------------------------------
  function update(dt) {
    state.time += dt;

    // Move planets in their orbits around the Sun
    updateBodyPositions(dt);

    const rocket = state.rocket;
    const stage = currentStage();
    if (!rocket) return;

    // --- Landed handling: glued to a body but moving with its orbit ------
    if (state.landed && !state.crashed && !state.escaped) {
      // Allow rotation while on the surface
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        rocket.angle += ROT_SPEED * dt;
      }
      if (keys["ArrowRight"] || keys["KeyD"]) {
        rocket.angle -= ROT_SPEED * dt;
      }

      const body = state.landedBody || getPrimaryBody(rocket.x, rocket.y);
      state.landedBody = body;

      // Body orbital velocity (assuming circular orbit around Sun)
      let bodyVx = 0;
      let bodyVy = 0;
      if (typeof body.orbitalRadius === "number") {
        const rOrbit = body.orbitalRadius;
        const omega = body.orbitalSpeed;
        const angle = body.angle;
        bodyVx = -Math.sin(angle) * rOrbit * omega;
        bodyVy =  Math.cos(angle) * rOrbit * omega;
      }

      const alt = state.landedAltitude != null ? state.landedAltitude : body.radius;
      const normalAngle =
        state.landedNormalAngle != null
          ? state.landedNormalAngle
          : Math.atan2(rocket.y - body.y, rocket.x - body.x);

      // Glue ship to the surface point
      rocket.x = body.x + Math.cos(normalAngle) * alt;
      rocket.y = body.y + Math.sin(normalAngle) * alt;
      rocket.vx = bodyVx;
      rocket.vy = bodyVy;

      const wantsThrust = stage && stage.fuel > 0 && (keys["ArrowUp"] || keys["KeyW"]);
      rocket.thrusting = !!wantsThrust;

      // Keep camera following while landed
      if (cameraFollow) {
        cameraX = rocket.x;
        cameraY = rocket.y;
      }

      if (!wantsThrust) {
        // Stay landed; no further physics
        return;
      } else {
        // Liftoff this frame: detach and fall through to normal flight
        state.landed = false;
        state.landedBody = null;
        state.message = "Liftoff from " + body.name + "!";
      }
    }

    // If crashed or escaped, stop physics
    if (state.crashed || state.escaped) {
      rocket.thrusting = false;
      return;
    }

    // Rotation in-flight
    if (keys["ArrowLeft"] || keys["KeyA"]) {
      rocket.angle += ROT_SPEED * dt;
    }
    if (keys["ArrowRight"] || keys["KeyD"]) {
      rocket.angle -= ROT_SPEED * dt;
    }

    if (stage && stage.fuel > 0) {
      rocket.thrusting = (keys["ArrowUp"] || keys["KeyW"]);
    } else {
      rocket.thrusting = false;
    }

    // Gravity from all bodies (Sun + planets)
    let ax = 0;
    let ay = 0;

    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      const gravAccMag = -body.mu / (r * r);
      ax += gravAccMag * (dx / r);
      ay += gravAccMag * (dy / r);
    }

    // Thrust
    if (rocket.thrusting && stage && stage.fuel > 0) {
      const mass = rocketMass();
      const thrustAcc = stage.thrust / mass;
      const tx = Math.cos(rocket.angle) * thrustAcc;
      const ty = Math.sin(rocket.angle) * thrustAcc;
      ax += tx;
      ay += ty;

      const fuelUseRate = 25;
      const dfuel = fuelUseRate * dt;
      stage.fuel = Math.max(0, stage.fuel - dfuel);
      if (stage.fuel <= 0) {
        rocket.thrusting = false;
        state.message = stage.name + " out of fuel.";
      }
    }

    // Integrate motion
    rocket.vx += ax * dt;
    rocket.vy += ay * dt;
    rocket.x += rocket.vx * dt;
    rocket.y += rocket.vy * dt;

    // Trail
    if (state.time % 0.02 < dt) {
      state.trail.push({ x: rocket.x, y: rocket.y });
      if (state.trail.length > 500) {
        state.trail.shift();
      }
    }

    // Collision with any body
    let collidedBody = null;
    let minDist = Infinity;
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= body.radius && r < minDist) {
        minDist = r;
        collidedBody = body;
      }
    }

    const speed = Math.hypot(rocket.vx, rocket.vy);

    if (collidedBody) {
      if (collidedBody === SUN || speed >= 3) {
        // Always crash into the Sun; crash if too fast elsewhere
        state.crashed = true;
        state.message = "CRASH into " + collidedBody.name + "! Press R to retry.";
        return;
      } else {
        // Gentle landing
        state.landed = true;
        state.landedBody = collidedBody;
        state.landedAltitude = collidedBody.radius;
        state.landedNormalAngle = Math.atan2(rocket.y - collidedBody.y, rocket.x - collidedBody.x);
        rocket.vx = 0;
        rocket.vy = 0;
        state.message = "Nice landing on " + collidedBody.name + "! Hold ↑ to take off or R to reset.";
        return;
      }
    }

    classifyOrbit();

    if (cameraFollow) {
      cameraX = rocket.x;
      cameraY = rocket.y;
    }
  }

  // --- Orbit classification relative to nearest body ---------------------
  function classifyOrbit() {
    const rocket = state.rocket;
    const body = getPrimaryBody(rocket.x, rocket.y);
    state.primaryBody = body;

    const rx = rocket.x - body.x;
    const ry = rocket.y - body.y;
    const r = Math.hypot(rx, ry);
    const vx = rocket.vx;
    const vy = rocket.vy;
    const v2 = vx * vx + vy * vy;
    const mu = body.mu;

    const specificEnergy = 0.5 * v2 - mu / r;

    state.orbitStable = false;
    state.orbitBound = false;
    state.orbitEscaping = false;
    state.orbitPeriod = null;
    state.orbitElements = null;

    if (specificEnergy > 0) {
      // Hyperbolic / escaping this body
      state.orbitEscaping = true;
      state.lastPeriapsis = null;
    } else if (specificEnergy < 0) {
      // Elliptic orbit about this body
      state.orbitBound = true;

      const h = rx * vy - ry * vx;
      const a = -mu / (2 * specificEnergy);
      let e2 = 1 - (h * h) / (a * mu);
      if (e2 < 0) e2 = 0;
      const e = Math.sqrt(e2);
      const rp = a * (1 - e);

      state.lastPeriapsis = rp - body.radius;
      state.orbitPeriod = 2 * Math.PI * Math.sqrt(Math.pow(a, 3) / mu);

      // Compute periapsis/apoapsis world positions via eccentricity vector
      if (isFinite(a) && e >= 0) {
        const rdotv = rx * vx + ry * vy;
        const factor1 = (v2 - mu / r) / mu;
        const factor2 = rdotv / mu;

        let ex = factor1 * rx - factor2 * vx;
        let ey = factor1 * ry - factor2 * vy;
        let emag = Math.hypot(ex, ey);

        if (emag < 1e-6) {
          // nearly circular: fallback to current radial direction
          ex = rx / r;
          ey = ry / r;
          emag = 1;
        }

        const ehatx = ex / emag;
        const ehaty = ey / emag;

        const rpRadius = a * (1 - e);
        const raRadius = a * (1 + e);

        const periX = body.x + ehatx * rpRadius;
        const periY = body.y + ehaty * rpRadius;
        const apoX  = body.x - ehatx * raRadius;
        const apoY  = body.y - ehaty * raRadius;

        state.orbitElements = {
          bodyName: body.name,
          bodyX: body.x,
          bodyY: body.y,
          periRadius: rpRadius,
          apoRadius: raRadius,
          periX,
          periY,
          apoX,
          apoY
        };
      }

      const atmo = body.atmosphere || 0;
      if (rp > body.radius + atmo) {
        state.orbitStable = true;
        if (!state.message.startsWith("Stable orbit around")) {
          state.message = "Stable orbit around " + body.name + " achieved!";
        }
      }
    } else {
      state.lastPeriapsis = null;
    }

    // System escape check
    const distFromOrigin = Math.hypot(rocket.x, rocket.y);
    if (!state.escaped && distFromOrigin > SYSTEM_ESCAPE_RADIUS) {
      state.escaped = true;
      state.message = "You escaped the system! Press R to restart.";
    }
  }

  // --- Predictive path: coast-only under all-body gravity, with MOVING bodies ---
    // --- Predictive path: coast-only under all-body gravity, with MOVING bodies ---
  function updatePredictedPath() {
    const rocket = state.rocket;
    if (!rocket || state.crashed || state.landed) {
      state.predictedPath = [];
      return;
    }

    // Clone rocket state
    let x = rocket.x;
    let y = rocket.y;
    let vx = rocket.vx;
    let vy = rocket.vy;

    const predicted = [];

    // Fixed small timestep + MUCH longer horizon (~180 s)
    const dt = 0.05;          // seconds per integration step
    const steps = 3600;       // 3600 * 0.05 = 180 seconds of simulated future
    const maxRadius = SYSTEM_ESCAPE_RADIUS * 1.5;

    // Clone bodies so we can move them without touching the real game state
    const predBodies = BODIES.map(b => ({
      name: b.name,
      x: b.x,
      y: b.y,
      radius: b.radius,
      mu: b.mu,
      atmosphere: b.atmosphere || 0,
      orbitalRadius: b.orbitalRadius,
      angle: b.angle,
      orbitalSpeed: b.orbitalSpeed
    }));

    const predSun = predBodies[0]; // central reference

    for (let i = 0; i < steps; i++) {
      // Advance orbital positions for bodies that orbit the Sun
      for (let j = 1; j < predBodies.length; j++) {
        const pb = predBodies[j];
        if (typeof pb.orbitalRadius === "number" && typeof pb.orbitalSpeed === "number") {
          pb.angle += pb.orbitalSpeed * dt;
          pb.x = predSun.x + Math.cos(pb.angle) * pb.orbitalRadius;
          pb.y = predSun.y + Math.sin(pb.angle) * pb.orbitalRadius;
        }
      }

      // Stop if we slam into something
      let hit = false;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= body.radius) {
          hit = true;
          break;
        }
      }
      if (hit) break;

      // Stop if we wander way out of the system
      const distFromOrigin = Math.hypot(x, y);
      if (distFromOrigin > maxRadius) break;

      // Gravity from all moving bodies (no thrust, coast-only)
      let ax = 0;
      let ay = 0;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        const gravAccMag = -body.mu / (r * r);
        ax += gravAccMag * (dx / r);
        ay += gravAccMag * (dy / r);
      }

      // Integrate
      vx += ax * dt;
      vy += ay * dt;
      x += vx * dt;
      y += vy * dt;

      // Subsample for drawing so the line isn't too dense
      if (i % 8 === 0) {
        predicted.push({ x, y });
      }
    }

    state.predictedPath = predicted;
  }


  // --- Drawing -----------------------------------------------------------
    // --- Drawing -----------------------------------------------------------
  function draw() {
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const scale = getScale();
    const centerX = w / 2;
    const centerY = h / 2;

    function worldToScreen(x, y) {
      return {
        x: centerX + (x - cameraX) * scale,
        y: centerY - (y - cameraY) * scale
      };
    }

    function screenWithinBounds(p) {
      return (
        p.x > -SAFE_COORD && p.x < SAFE_COORD &&
        p.y > -SAFE_COORD && p.y < SAFE_COORD
      );
    }

    // Orbital paths (routes) for planets that orbit the Sun
    ctx.save();
    ctx.strokeStyle = "rgba(255, 255, 255, 0.12)";
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 6]); // faint dashed circles

    const sunScreen = worldToScreen(SUN.x, SUN.y);
    for (const body of BODIES) {
      if (typeof body.orbitalRadius === "number") {
        const rPx = body.orbitalRadius * scale;
        if (rPx < 1 || rPx > SAFE_ORBIT_RADIUS_PX) continue; // skip absurdly large circles
        ctx.beginPath();
        ctx.arc(sunScreen.x, sunScreen.y, rPx, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    ctx.restore();

    // Bodies: Sun + planets
    for (const body of BODIES) {
      ctx.save();
      const screen = worldToScreen(body.x, body.y);
      const rPx = body.radius * scale;

      const grd = ctx.createRadialGradient(
        screen.x - rPx * 0.3,
        screen.y - rPx * 0.3,
        rPx * 0.2,
        screen.x,
        screen.y,
        rPx
      );
      const c = body.colors;
      grd.addColorStop(0, c.inner);
      grd.addColorStop(0.5, c.mid);
      grd.addColorStop(1, c.outer);

      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, rPx, 0, Math.PI * 2);
      ctx.fill();

      const atmo = body.atmosphere || 0;
      if (atmo > 0) {
        const atmoRadiusPx = (body.radius + atmo) * scale;
        if (atmoRadiusPx < SAFE_ORBIT_RADIUS_PX) {
          ctx.strokeStyle = "rgba(80,200,255,0.25)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(screen.x, screen.y, atmoRadiusPx, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Label
      ctx.fillStyle = "#ffffff";
      ctx.font = "11px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(body.name, screen.x, screen.y + rPx + 4);
      ctx.restore();
    }

    // Predicted trajectory (with clipping)
    if (state.predictedPath && state.predictedPath.length > 1) {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.predictedPath.length; i++) {
        const p = worldToScreen(state.predictedPath[i].x, state.predictedPath[i].y);
        const onScreen = screenWithinBounds(p);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Trail (also clipped)
    if (state.trail.length > 1) {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(180,180,255,0.6)";
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.trail.length; i++) {
        const p = worldToScreen(state.trail[i].x, state.trail[i].y);
        const onScreen = screenWithinBounds(p);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Apsis markers (Periapsis / Apoapsis) for current bound orbit
    if (state.orbitBound && state.orbitElements) {
      const oe = state.orbitElements;

      const periScreen = worldToScreen(oe.periX, oe.periY);
      const apoScreen  = worldToScreen(oe.apoX, oe.apoY);
      const bodyScreen = worldToScreen(oe.bodyX, oe.bodyY);

      if (screenWithinBounds(periScreen) || screenWithinBounds(apoScreen) || screenWithinBounds(bodyScreen)) {
        ctx.save();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;

        // Lines from body to apsides
        ctx.strokeStyle = "rgba(0,255,136,0.5)";
        ctx.beginPath();
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(periScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(periScreen.x, periScreen.y);
        }
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(apoScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(apoScreen.x, apoScreen.y);
        }
        ctx.stroke();

        // Periapsis marker
        if (screenWithinBounds(periScreen)) {
          ctx.fillStyle = "#00ff88";
          ctx.beginPath();
          ctx.arc(periScreen.x, periScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#00ff88";
          ctx.fillText("Pe", periScreen.x + 6, periScreen.y - 2);
        }

        // Apoapsis marker
        if (screenWithinBounds(apoScreen)) {
          ctx.fillStyle = "#ff66ff";
          ctx.beginPath();
          ctx.arc(apoScreen.x, apoScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#ff66ff";
          ctx.fillText("Ap", apoScreen.x + 6, apoScreen.y - 2);
        }

        ctx.restore();
      }
    }

    // Rocket
    const rocket = state.rocket;
    const rocketScreen = worldToScreen(rocket.x, rocket.y);

    ctx.save();
    ctx.translate(rocketScreen.x, rocketScreen.y);
    ctx.rotate(-rocket.angle + Math.PI / 2);

    const bodyWidth = 6;
    const bodyHeight = 20;

    const stageIndex = state.currentStageIndex;
    const colors = ["#dddddd", "#ffcc66", "#99ccff"];
    const bodyColor = colors[Math.min(colors.length - 1, stageIndex + 1)];

    // Body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.7);
    ctx.lineTo(bodyWidth / 2, bodyHeight * 0.3);
    ctx.lineTo(0, bodyHeight * 0.5);
    ctx.lineTo(-bodyWidth / 2, bodyHeight * 0.3);
    ctx.closePath();
    ctx.fill();

    // Nose
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.9);
    ctx.lineTo(bodyWidth / 2, -bodyHeight * 0.7);
    ctx.lineTo(-bodyWidth / 2, -bodyHeight * 0.7);
    ctx.closePath();
    ctx.fill();

    // Flame
    if (rocket.thrusting && !state.crashed && !state.landed) {
      ctx.fillStyle = "#ff9933";
      ctx.beginPath();
      ctx.moveTo(0, bodyHeight * 0.5);
      ctx.lineTo(bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.lineTo(-bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // HUD
    const primary = state.primaryBody || getPrimaryBody(rocket.x, rocket.y);
    const dxp = rocket.x - primary.x;
    const dyp = rocket.y - primary.y;
    const rPrimary = Math.hypot(dxp, dyp);
    const alt = rPrimary - primary.radius;
    const speed = Math.hypot(rocket.vx, rocket.vy);
    const radialVel = (dxp * rocket.vx + dyp * rocket.vy) / rPrimary;

    const stage = currentStage();
    const stageName = stage ? stage.name : "None";
    const fuel = stage ? stage.fuel : 0;
    const maxFuel = stage ? stage.maxFuel : 1;
    const fuelPct = Math.max(0, Math.min(100, (fuel / maxFuel) * 100));

    let orbitStatus;
    if (state.orbitEscaping) {
      orbitStatus = state.escaped ? "Escaped system" : "Escaping " + primary.name;
    } else if (state.orbitStable) {
      orbitStatus = "Stable orbit around " + primary.name;
    } else if (state.orbitBound) {
      orbitStatus = "Bound to " + primary.name + " (reentry)";
    } else {
      orbitStatus = "Suborbital / transitioning";
    }

    const periapsisText =
      state.lastPeriapsis != null
        ? (state.lastPeriapsis >= 0
            ? state.lastPeriapsis.toFixed(1) + " km"
            : "surface")
        : "unknown";

    const apoapsisText =
      state.orbitElements && state.orbitBound
        ? (state.orbitElements.apoRadius - primary.radius).toFixed(1) + " km"
        : "unknown";

    const camModeText = cameraFollow ? "Follow ship" : "Free";

    overlay.textContent =
      "BODY: " + primary.name + "\n" +
      "ALT: " + alt.toFixed(1) + " km\n" +
      "SPEED: " + speed.toFixed(2) + " km/s\n" +
      "VERT SPD: " + radialVel.toFixed(2) + " km/s (" + (radialVel >= 0 ? "↑" : "↓") + ")\n" +
      "STAGE: " + stageName + " (" + fuelPct.toFixed(0) + "% fuel)\n" +
      "ORBIT: " + orbitStatus + "\n" +
      "Periapsis: " + periapsisText + "\n" +
      "Apoapsis: " + apoapsisText + "\n" +
      "WARP: " + timeScale.toFixed(2) + "x\n" +
      "ZOOM: " + cameraZoom.toFixed(2) + "x\n" +
      "CAM: " + camModeText + "\n\n" +
      state.message;
  }


  // --- Main loop with substepping ---------------------------------------
  let lastTime = performance.now();
  function loop(now) {
    const realDt = (now - lastTime) / 1000;
    lastTime = now;

    let dtRemaining = Math.max(0, realDt * timeScale);
    const maxStep = 0.05;
    const maxStepsPerFrame = 100;
    let steps = 0;

    while (dtRemaining > 0 && steps < maxStepsPerFrame) {
      const step = Math.min(maxStep, dtRemaining);
      update(step);
      dtRemaining -= step;
      steps++;
    }

    updatePredictedPath();
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
