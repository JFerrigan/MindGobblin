<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pong Duel</title>
<style>
  :root {
    --bg: #1a2844;
    --accent: #b6f0ff;
    --muted: #9fb6c2;
    --panel: rgba(255,255,255,0.04);
  }
  html, body {
    height:100%;
    margin:0;
    font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(1000px 500px at 10% 10%, rgba(255,255,255,0.02), transparent),
                var(--bg);
    color: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  .container {
    width: 900px;
    max-width: 95vw;
    margin: 24px;
    text-align: center;
    position: relative; /* make touch controls positionable relative to this */
  }
  h1 { margin: 0 0 8px; font-weight: 600; letter-spacing: 0.6px; }
  #game {
    display: block;
    width: 100%;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,white,0.0));
    border-radius: 8px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    overflow: hidden;
  }
  .bar {
    margin-top: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 900px;
    color: var(--muted);
    font-size: 14px;
  }
  .controls {
    display: flex;
    align-items: center;
    gap: 12px; /* adds some space between control hint text and Leave button */
  }

  .hint {
    color: var(--muted);
    font-size: 13px;
    text-align: right;
  }
  #status { flex: 1; text-align: left; }
  button {
    background: transparent;
    border: 1px solid rgb(117, 122, 170);
    color: var(--accent);
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
  }

  /* ---------- TOUCH / MOUSE BUTTONS ---------- */

  /* container-relative wrappers */
  .touch-wrapper {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none; /* allow clicks through except for the control elements themselves */
  }

  /* generic triangle button */
  .triangle-btn {
    pointer-events: auto; /* enable interaction */
    position: absolute;
    width: 0;
    height: 0;
    opacity: 0.75;
    transition: opacity 0.08s, filter 0.08s;
    user-select: none;
    touch-action: none;
  }
  .triangle-btn.pressed {
    opacity: 1;
    filter: brightness(1.6);
  }

  /* up triangle (pointing up) */
  .triangle-up {
    border-left: 28px solid transparent;
    border-right: 28px solid transparent;
    border-bottom: 44px solid var(--accent);
  }

  /* down triangle (pointing down) */
  .triangle-down {
    border-left: 28px solid transparent;
    border-right: 28px solid transparent;
    border-top: 44px solid var(--accent);
  }

  /* small responsive sizing for narrow viewports */
  @media (max-width: 420px) {
    .triangle-up { border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 32px solid var(--accent); }
    .triangle-down { border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 32px solid var(--accent); }
  }

  /* Serve tap area (invisible rectangle over the board center) */
  .serve-zone {
    pointer-events: auto;
    position: absolute;
    background: rgba(255,255,255,0.01); /* almost invisible but receives events */
    border-radius: 6px;
    touch-action: none;
  }

  /* --- PORTRAIT --- */
  @media (orientation: portrait) {
    .bar {
      flex-direction: row;
      flex-wrap: nowrap;
      font-size: clamp(9px, 2.4vw, 13px);
    }
    .controls .hint {
      font-size: clamp(8px, 2vw, 12px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #leaveBtn {
      padding: 3px 6px;
      font-size: clamp(9px, 2.3vw, 12px);
    }

    /* Move triangle buttons slightly lower */
    .triangle-up,
    .triangle-down {
      transform: translateY(10px);
      border-left: 30px solid transparent;
      border-right: 30px solid transparent;
    }
  }

  /* --- LANDSCAPE --- */
  @media (orientation: landscape) {
    html, body {
      justify-content: center;
      align-items: center;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      max-width: 90vw;
    }

    canvas#game {
      max-height: 70vh;
      width: auto;
      height: auto;
      display: block;
      margin: 0 auto;
    }

    /* Big triangle buttons for easier touch control */
    .triangle-up,
    .triangle-down {
      border-left: 30px solid transparent;
      border-right: 30px solid transparent;
    }
    .triangle-up {
      border-bottom: 50px solid var(--accent);
    }
    .triangle-down {
      border-top: 50px solid var(--accent);
    }

    /* Centered and compact bottom bar */
    .bar {
      margin-top: 10px;
      max-width: 80vw;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      font-size: clamp(9px, 1.2vw, 12px);
      gap: 8px;
    }

    .controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .controls .hint {
      font-size: clamp(8px, 1vw, 11px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #leaveBtn {
      font-size: clamp(9px, 1vw, 11px);
      padding: 3px 6px;
    }
  }

  /* --- Make serve zone invisible but still clickable --- */
  .serve-zone {
    opacity: 0;
    pointer-events: auto;
  }

  /* --- Prevent accidental selection/drag across all modes --- */
  html, body, canvas, button, .bar, .triangle-btn, .serve-zone {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
  }
</style>
</head>
<body>
  <div class="container">
    <!--<h1>Pong Duel</h1>-->
    <canvas id="game" width="900" height="500"></canvas>

    <!-- TOUCH / MOUSE CONTROLS (minimal DOM added) -->
    <div class="touch-wrapper" id="touchWrapper" aria-hidden="true">
      <div id="btnUp" class="triangle-btn triangle-up" role="button" aria-label="Up"></div>
      <div id="btnDown" class="triangle-btn triangle-down" role="button" aria-label="Down"></div>
      <div id="serveZone" class="serve-zone" aria-label="Serve"></div>
    </div>

    <div class="bar">
      <div id="status">Connecting…</div>
      <div class="controls">
        <span class="hint"><strong>Space bar</strong> or <strong>Click Center:</strong> Serve &nbsp; · &nbsp; <strong>↑</strong><strong>↓</strong> Move</span>
        <button id="leaveBtn">Leave</button>
      </div>
    </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/9.0.6/signalr.min.js"></script>
<script>
  const params = new URLSearchParams(window.location.search);
  const lobbyId = params.get('lobbyId');
  const mySide = params.get('side');
  if (!lobbyId || !mySide) {
    alert('Invalid access. Go back to lobbies.');
    window.location.href = 'pong-lobbies.html';
  }

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const PADDLE_WIDTH = 14;
  const PADDLE_HEIGHT = Math.round(h * 0.18);
  const PADDLE_MARGIN = 24;
  const BALL_RADIUS = 9;
  const PADDLE_SPEED = 300; // pixels/second

  let inputTimer;

  // local paddle and ball positions -> used for rendering
  let local = {
    leftY: (h - PADDLE_HEIGHT) / 2,
    rightY: (h - PADDLE_HEIGHT) / 2,
    ballX: w/2,
    ballY: h/2,
    scoreLeft: 0,
    scoreRight: 0
  };

  // desired paddle position (what player wants) -> sent to server. NOT used for rendering.
  let desired = {
    leftY: (h - PADDLE_HEIGHT) / 2,
    rightY: (h - PADDLE_HEIGHT) / 2
  };

  // for position infmroation from the server
  let target = { ...local, ts: performance.now() };

  // New interpolation helpers
  let prevTarget = { ...local, ts: performance.now() };
  let stateLerpStart = performance.now();
  const SERVER_HZ = 30;
  const SERVER_INTERVAL = 1000 / SERVER_HZ;

  let victoryTime = null;
  let victoryReached = false;
  let victoryMsg = null;
  let serving = false;
  let servingMsg = null;
  let servingSide = null;
  let gameRestart = false;
  let lastFrameTime = performance.now();

  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key] = true;
    e.preventDefault();
    if (e.code === 'Space') {
      if (mySide === servingSide) {
        serving = false;
        conn.invoke('ServeBall', lobbyId)
            .catch(err => console.error("Serve failed:", err));
      }
    }
  });
  window.addEventListener('keyup', e => {
    delete keys[e.key];
    e.preventDefault();
  });

  window.addEventListener('beforeunload', () => {
    clearInterval(inputTimer);
    conn.stop();
  });

  const conn = new signalR.HubConnectionBuilder()
    .withUrl(`/ponggamehub?context=duel&lobbyId=${encodeURIComponent(lobbyId)}&side=${encodeURIComponent(mySide)}`)
    .withAutomaticReconnect()
    .build();

  const statusElem = document.getElementById('status');

  conn.onclose(() => statusElem.textContent = 'Disconnected');
  conn.onreconnecting(() => statusElem.textContent = 'Reconnecting...');
  conn.onreconnected(() => statusElem.textContent = 'Connected');

  // --- StateUpdate handler ---
  conn.on("StateUpdate", s => {
    prevTarget = { ...target }; // store previous snapshot

    target.ballX = s.ballX;
    target.ballY = s.ballY;
    target.leftY = s.leftY;
    target.rightY = s.rightY;
    target.scoreLeft = s.scoreLeft;
    target.scoreRight = s.scoreRight;
    target.ts = performance.now();
    stateLerpStart = performance.now();

    if (s.isReset) {
      serving = true;
      // Snap instantly on reset
      local.ballX = s.ballX;
      local.ballY = s.ballY;
      prevTarget.ballX = s.ballX;
      prevTarget.ballY = s.ballY;
    }

    if (gameRestart) {
      gameRestart = false;
      local.leftY = s.leftY;
      local.rightY = s.rightY;
      desired.leftY = s.leftY;
      desired.rightY = s.rightY;
      prevTarget = { ...target }; // make previous and target same on reset
    }
  });

  conn.on("DuelEnded", msg => {
    serving = false;
    alert("Duel ended: " + msg);
  });
  conn.on("LobbyClosing", msg => {
    serving = false;
    alert("Lobby closing down: " + msg);
    window.location.href = 'pong-lobbies.html';
  });
  conn.on("VictoryReached", msg => {
    serving = true;
    victoryTime = performance.now();
    victoryReached = true;
    victoryMsg = msg;
    gameRestart = true;
  });
  conn.on("ForceReset", () => {
    serving = true;
    gameRestar = true;
  });
  conn.on("SideServing", msg => {
    serving = true;
    servingMsg = `${msg} Serving`;
    servingSide = msg;
  });
  conn.on("BallServed", () => {
    serving = false;
  });

  async function start() {
    await conn.start();
    statusElem.textContent = 'Playing on ';
    const boldSide = document.createElement('strong');
    boldSide.textContent = mySide;
    statusElem.appendChild(boldSide);
    statusElem.append(' side');
    await conn.invoke("CheckDuel", lobbyId, mySide);
  }
  start().catch(e => {
    console.error(e);
    statusElem.textContent = 'Connection error';
  });

  document.getElementById('leaveBtn').addEventListener('click', async () => {
    clearInterval(inputTimer);
    try { await conn.send('LeaveLobby', lobbyId, mySide); }
    catch(e) { console.error(e); }
    await conn.stop();
    setTimeout(() => {
      window.location.href = 'pong-lobbies.html';
    }, 150);
  });

  // No local paddle motion — only send input to server
  function updateLocalPaddle(now) {
    const dt = (now - lastFrameTime) / 1000;
    lastFrameTime = now;

    const move = PADDLE_SPEED * dt;
    if (mySide === 'Left') {
      if (keys['ArrowUp']) desired.leftY -= move;
      if (keys['ArrowDown']) desired.leftY += move;
      desired.leftY = Math.max(0, Math.min(desired.leftY, h - PADDLE_HEIGHT));
    } else {
      if (keys['ArrowUp']) desired.rightY -= move;
      if (keys['ArrowDown']) desired.rightY += move;
      desired.rightY = Math.max(0, Math.min(desired.rightY, h - PADDLE_HEIGHT));
    }

    requestAnimationFrame(updateLocalPaddle);
  }
  requestAnimationFrame(updateLocalPaddle);

  // Send inputs to server at 30 Hz (no local motion)
  const SEND_HZ = 30;
  setInterval(() => {
    const paddleY = (mySide === 'Left') ? desired.leftY : desired.rightY;
    conn.invoke('SendInput', lobbyId, paddleY, mySide).catch(e => console.error(e));
  }, 1000 / SEND_HZ);

  function lerp(a, b, t) { return a + (b - a) * t; }

  function render(now) {
    // Interpolate from prevTarget -> target
    const t = Math.min(1, (now - stateLerpStart) / SERVER_INTERVAL);
    local.ballX = lerp(prevTarget.ballX, target.ballX, t);
    local.ballY = lerp(prevTarget.ballY, target.ballY, t);
    local.leftY = lerp(prevTarget.leftY, target.leftY, t);
    local.rightY = lerp(prevTarget.rightY, target.rightY, t);
    local.scoreLeft = target.scoreLeft;
    local.scoreRight = target.scoreRight;

    // draw background
    ctx.fillStyle = '#071021';
    ctx.fillRect(0, 0, w, h);

    // net
    ctx.fillStyle = '#ffffff22';
    for (let y = 10; y < h; y += 24) {
      ctx.fillRect(w/2 - 2, y, 4, 12);
    }

    // paddles
    ctx.fillStyle = '#b6f0ff';
    roundRect(ctx, PADDLE_MARGIN, local.leftY, PADDLE_WIDTH, PADDLE_HEIGHT, 6);
    roundRect(ctx, w - PADDLE_MARGIN - PADDLE_WIDTH, local.rightY, PADDLE_WIDTH, PADDLE_HEIGHT, 6);

    // ball
    ctx.beginPath();
    ctx.arc(local.ballX, local.ballY, BALL_RADIUS, 0, Math.PI*2);
    ctx.fillStyle = '#eaffff';
    ctx.fill();

    // scores
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.font = '700 40px Inter, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(local.scoreLeft, w*0.25, 30);
    ctx.fillText(local.scoreRight, w*0.75, 30);

    // waiting message
    if ((performance.now() - target.ts) > 2000) {
      ctx.fillStyle = 'rgba(255,200,0,1)';
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Waiting for Opponent…', w/2, h/2 - 60);
    }

    // victory
    if (victoryReached) {
      if ((performance.now() - victoryTime) < 2000) {
        ctx.fillStyle = 'rgba(255,255,1,1)';
        ctx.font = '24px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(victoryMsg, w/2, h/2 - 60);
      } else {
        victoryReached = false;
      }
    }

    // serving message
    if (serving) {
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = '24px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(servingMsg, w/2, h/2 - 20);
    }

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
  }

  /* ---------- TOUCH / MOUSE BUTTON BEHAVIOR (minimal JS added) ---------- */

  const btnUp = document.getElementById('btnUp');
  const btnDown = document.getElementById('btnDown');
  const serveZone = document.getElementById('serveZone');
  const touchWrapper = document.getElementById('touchWrapper');

  // Helper to set pressed visual and key state
  function pressKey(key) {
    // set key true and add pressed class
    keys[key] = true;
    if (key === 'ArrowUp') btnUp.classList.add('pressed');
    if (key === 'ArrowDown') btnDown.classList.add('pressed');
  }
  function releaseKey(key) {
    delete keys[key];
    if (key === 'ArrowUp') btnUp.classList.remove('pressed');
    if (key === 'ArrowDown') btnDown.classList.remove('pressed');
  }

  // Add both touch and mouse handlers for a button element
  function addPressHandlers(el, key) {
    // Touch events
    el.addEventListener('touchstart', e => {
      e.preventDefault();
      pressKey(key);
    }, { passive: false });
    el.addEventListener('touchend', e => {
      e.preventDefault();
      releaseKey(key);
    }, { passive: false });
    el.addEventListener('touchcancel', e => {
      e.preventDefault();
      releaseKey(key);
    }, { passive: false });

    // Mouse events (mousedown + mouseup + mouseleave)
    el.addEventListener('mousedown', e => {
      e.preventDefault();
      pressKey(key);
    });
    // releasing mouse anywhere should release key (mouseup on window)
    window.addEventListener('mouseup', e => {
      // release whether mouseup occurred on element or not
      releaseKey(key);
    });
    el.addEventListener('mouseleave', e => {
      // if cursor leaves while pressed, also release visual
      // (leave doesn't necessarily release the key if mouse button still down,
      // but we choose to mirror touch behavior and clear on leave)
      el.classList.remove('pressed');
    });
  }

  addPressHandlers(btnUp, 'ArrowUp');
  addPressHandlers(btnDown, 'ArrowDown');

  // Serve zone: touch or click centered region -> serve if allowed
  function handleServeAttempt() {
    if (serving && mySide === servingSide) {
      // trigger same server call as space bar
      conn.invoke('ServeBall', lobbyId).catch(err => console.error("Serve failed:", err));
      // visually nothing to toggle for serve zone
    }
  }

  serveZone.addEventListener('touchstart', e => {
    e.preventDefault();
    handleServeAttempt();
  }, { passive: false });

  serveZone.addEventListener('mousedown', e => {
    e.preventDefault();
    handleServeAttempt();
  });

  /* Layout logic: position buttons outside the canvas based on available horizontal space.
     We DON'T detect device type; we simply check horizontal space around the canvas.
     If each side's free space >= threshold, we place left/right; otherwise bottom.
  */
  function layoutControls() {
    const portrait = window.matchMedia('(orientation: portrait)').matches;
    const wrapperRect = touchWrapper.getBoundingClientRect();
    const rect = canvas.getBoundingClientRect();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    // Keep everything centered in both orientations
    document.body.style.display = 'flex';
    document.body.style.flexDirection = 'column';
    document.body.style.justifyContent = 'center';
    document.body.style.alignItems = 'center';

    // Slight scaling if canvas too tall in landscape
    if (!portrait && rect.height > vh * 0.72) {
      const scale = (vh * 0.72) / rect.height;
      canvas.style.transform = `scale(${scale})`;
      canvas.style.transformOrigin = 'center center';
    } else {
      canvas.style.transform = '';
    }

    const updatedRect = canvas.getBoundingClientRect();
    const freeEachSide = (vw - updatedRect.width) / 2;

    if (!portrait && freeEachSide >= 60) {
      // --- LANDSCAPE ---
      const centerY = updatedRect.top + updatedRect.height / 2;
      const btnSize = Math.max(40, updatedRect.height * 0.12);

      // Move buttons closer to the board (reduced horizontal offset)
      const horizontalOffset = btnSize * 1.2;
      const verticalOffset = btnSize * 0.5;

      // Left-side (up) button
      btnUp.style.left = (updatedRect.left - horizontalOffset - 30 - wrapperRect.left) + 'px';
      btnUp.style.top = (centerY - verticalOffset - wrapperRect.top) + 'px';

      // Right-side (down) button
      btnDown.style.left = (updatedRect.right + (horizontalOffset - 4 - btnSize * 0.6) - wrapperRect.left) + 'px';
      btnDown.style.top = (centerY - verticalOffset - wrapperRect.top) + 'px';
    } else {
      // --- PORTRAIT ---
      const leftX = updatedRect.left + updatedRect.width * 0.25 - 24;
      const rightX = updatedRect.left + updatedRect.width * 0.75 - 24;
      const yBelow = updatedRect.bottom + 45; // slightly lower

      btnUp.style.left = (leftX - wrapperRect.left) + 'px';
      btnUp.style.top = (yBelow - wrapperRect.top) + 'px';
      btnDown.style.left = (rightX - wrapperRect.left) + 'px';
      btnDown.style.top = (yBelow - wrapperRect.top) + 'px';
    }

    // Serve zone (invisible but centered)
    const serveW = Math.max(50, updatedRect.width * 0.15);
    const serveH = Math.max(36, updatedRect.height * 0.1);
    serveZone.style.width = serveW + 'px';
    serveZone.style.height = serveH + 'px';
    serveZone.style.left =
      updatedRect.left + updatedRect.width / 2 - serveW / 2 - wrapperRect.left + 'px';
    serveZone.style.top =
      updatedRect.top + updatedRect.height / 2 - serveH / 2 - wrapperRect.top + 'px';
  }

  // initial layout and on resize/scroll (canvas may move)
  window.addEventListener('resize', () => setTimeout(layoutControls, 50));
  window.addEventListener('scroll', layoutControls);
  window.addEventListener('orientationchange', () => setTimeout(layoutControls, 200));
  // small debounce to initial layout after fonts/layout stabilized
  setTimeout(layoutControls, 100);
  // also layout after load (in case)
  window.addEventListener('load', () => setTimeout(layoutControls, 100));

</script>
</body>
</html>
