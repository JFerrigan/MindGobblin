<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Captain-Forever-ish (Built on Asteroids Base)</title>
  <style>
    :root{
      --fg:#e7ecef;--muted:#9aa6b2;--brand:#57e6c1;--danger:#ff6b6b;--bg:#000;
    }
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Inter,Arial;overflow:hidden}
    #hud{position:fixed;left:10px;top:10px;display:flex;gap:8px;z-index:10}
    .pill{background:rgba(255,255,255,.08);padding:4px 8px;border-radius:8px}
    #msg{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    #msg .card{background:rgba(17,24,38,.9);border:1px solid #1f2a3c;padding:14px 16px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.35)}
    canvas{display:block}
    kbd{background:#111826;border:1px solid #1f2a3c;border-bottom-width:2px;border-radius:6px;padding:0 6px;margin:0 2px}
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="hud">
  <div class="pill">Score: <span id="score">0</span></div>
  <div class="pill">Best: <span id="best">0</span></div>
  <div class="pill">Lives: <span id="lives">3</span></div>
  <div class="pill">Level: <span id="level">1</span></div>
  <div class="pill">Parts: <span id="partCount">0</span></div>
</div>
<div id="msg"></div>

<script>
(() => {
  // ------------------------------------------------------------
  // Canvas setup
  // ------------------------------------------------------------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const DPR = Math.min(2, devicePixelRatio || 1);
  function resize(){
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize); resize();

  // ------------------------------------------------------------
  // HUD
  // ------------------------------------------------------------
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const partCountEl = document.getElementById('partCount');
  const msg = document.getElementById('msg');
  function setText(el,v){ if(el) el.textContent = v; }
  function showMsg(html){ msg.innerHTML = `<div class="card">${html}</div>`; }
  function hideMsg(){ msg.innerHTML=''; }

  // ------------------------------------------------------------
  // Helpers & tuning
  // ------------------------------------------------------------
  const TAU = Math.PI*2;
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy;};
  const wrap=(o)=>{ if(o.x<0) o.x+=innerWidth; if(o.x>innerWidth) o.x-=innerWidth;
                    if(o.y<0) o.y+=innerHeight; if(o.y>innerHeight) o.y-=innerHeight; };

  // Classic base tuning
  const BULLET_SPEED = 9.0;
  const BULLET_RANGE = 1000;
  const ENEMY_BULLET_SPEED = 6;
  const ENEMY_BULLET_RANGE = 1100;

  // Modular tuning
  const GRID = 16;                 // attachment grid step around core
  const ATTACH_RANGE = 40;         // distance to snap salvage
  const TRACTOR_RANGE = 260;       // tractor max range
  const TRACTOR_PULL = 0.9;        // salvage pull speed
  const BASE_THRUST = 0.10;        // core thrust baseline
  const THRUSTER_THRUST = 0.08;    // per-thruster added thrust
  const BASE_FIRE_CD = 220;        // ms; reduced by guns
  const PER_GUN_BONUS = 60;        // ms ROF improvement per gun (cap applied)
  const MAX_VOLLEY_SPREAD = 0.18;  // radians
  const MAX_BULLETS = 4;           // cap per volley for perf

  // ------------------------------------------------------------
  // Part catalog (data-driven)
  // ------------------------------------------------------------
  const PartDefs = {
    Core:     {slot:'Core',     hp: Infinity, size:1, draw:(ctx)=>{ ctx.strokeStyle='#e7ecef'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,10,0,TAU); ctx.stroke(); }},
    Girder:   {slot:'Girder',   hp: 40, size:1, draw:(ctx)=>{ ctx.strokeStyle='rgba(231,236,239,.9)'; ctx.lineWidth=2; ctx.strokeRect(-8,-8,16,16); }},
    Thruster: {slot:'Thruster', hp: 30, size:1, thrust: THRUSTER_THRUST,
               draw:(ctx)=>{ ctx.strokeStyle='#76ffd9'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(-8,-7); ctx.lineTo(-8,7); ctx.closePath(); ctx.stroke(); }},
    Gun:      {slot:'Gun',      hp: 25, size:1,
               draw:(ctx)=>{ ctx.strokeStyle='#57e6c1'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(-6,-4); ctx.lineTo(-6,4); ctx.closePath(); ctx.stroke(); }},
  };

  // Ship part instance
  function makePart(kind, gx, gy, rot=0){
    const def = PartDefs[kind];
    return { kind, gx, gy, rot, hp: def.hp, dead:false };
  }

  // ------------------------------------------------------------
  // Entities
  // ------------------------------------------------------------
  function makeShip(startX, startY, player=true){
    // grid coords relative to core (0,0). Each cell is GRID px.
    const parts = [
      makePart('Core', 0, 0, 0),
      makePart('Thruster', -1, 0, 0),
      makePart('Gun', 1, 0, 0),
      makePart('Girder', 0, -1, 0),
      makePart('Girder', 0, 1, 0),
    ];
    return {
      type:'ship',
      player,
      x:startX, y:startY,
      angle: -Math.PI/2,
      vx:0, vy:0,
      parts,
      fireCD: 0,
      r: 14,
      dead:false,
      invUntil: 0
    };
  }

  function makeDrone(level){
    // tiny enemy kit: core + 1 thruster + 1 gun (sometimes extra girder)
    const x = Math.random()<0.5? -30: innerWidth+30;
    const y = rand(40, innerHeight-40);
    const ship = makeShip(x,y,false);
    ship.parts = [ makePart('Core',0,0,0), makePart('Thruster',-1,0,0), makePart('Gun',1,0,0) ];
    if(Math.random()<0.5) ship.parts.push(makePart('Girder',0,1,0));
    ship.angle = Math.random()*TAU;
    ship.vx = (x<0?1:-1)*(1.0+level*0.12);
    ship.vy = rand(-0.6,0.6);
    ship.ai = { fireT: 0, dirT: 0 };
    return ship;
  }

  function asteroid(x,y,size=3){
    const speed = rand(0.3, 1) + state.level*0.05;
    const a = rand(0,TAU);
    const points = 10 + Math.floor(Math.random()*5);
    const irregular = []; for(let i=0;i<points;i++) irregular.push(rand(0.75,1.25));
    return {type:'asteroid', x,y, r: size*18, size, angle:0, spin:rand(-0.02,0.02),
            vx: Math.cos(a)*speed, vy: Math.sin(a)*speed, irregular };
  }

  function bullet(x,y,angle,owner='player'){
    const sp = BULLET_SPEED;
    return {type:'bullet', owner, x,y, r:2, vx:Math.cos(angle)*sp, vy:Math.sin(angle)*sp, range:BULLET_RANGE, dead:false};
  }

  function particle(x,y,vx,vy,life,color){
    return {type:'particle',x,y,vx,vy,life,color};
  }

  function salvage(kind,x,y){
    return {type:'salvage', kind, x,y, vx:rand(-0.6,0.6), vy:rand(-0.6,0.6), dead:false};
  }

  // ------------------------------------------------------------
  // State
  // ------------------------------------------------------------
  const state = {
    running:true,
    entities:[],
    particles:[],
    level:1,
    score:0,
    best: Number(localStorage.getItem('cfish_best')||0),
    lives:3,
    keys:new Set(),
    nextShotAt:0,
    kills:0,
    lastSpawn:0,
    tractor:false,
  };
  setText(bestEl,state.best);

  // ------------------------------------------------------------
  // Input
  // ------------------------------------------------------------
  addEventListener('keydown', (e)=>{
    state.keys.add(e.code);
    if(e.code==='Space') e.preventDefault();
    if(e.code==='KeyF') state.tractor = true;
    if(e.code==='KeyP'){ state.running = !state.running; if(!state.running) showMsg('<h3 style="margin:0 0 8px">Paused</h3><div>Press <kbd>P</kbd> to resume</div>'); else hideMsg(); }
    if(e.code==='KeyR'){ reset(); }
  });
  addEventListener('keyup', (e)=>{
    state.keys.delete(e.code);
    if(e.code==='KeyF') state.tractor = false;
  });

  // ------------------------------------------------------------
  // Level / Reset
  // ------------------------------------------------------------
  function spawnLevel(){
    const ship = state.entities.find(e=>e.type==='ship' && e.player) || makeShip(innerWidth/2,innerHeight/2,true);
    state.entities = [ship];
    // asteroids
    for(let i=0;i<2+state.level;i++){
      let x,y; let tries=0;
      do{ x=rand(0,innerWidth); y=rand(0,innerHeight); tries++; }
      while(dist2(x,y,ship.x,ship.y) < 220*220 && tries<50);
      state.entities.push(asteroid(x,y,3));
    }
    // enemy drones
    for(let i=0;i<1+Math.floor(state.level/2); i++){
      state.entities.push(makeDrone(state.level));
    }
    ship.invUntil = performance.now()+2000;
    setText(levelEl,state.level);
    updatePartHUD(ship);
  }

  function reset(){
    state.level=1; state.score=0; state.lives=3; state.kills=0; state.particles.length=0;
    const ship = makeShip(innerWidth/2,innerHeight/2,true);
    state.entities=[ship];
    setText(scoreEl,0); setText(livesEl,3); hideMsg();
    spawnLevel();
  }

  // ------------------------------------------------------------
  // Part graph helpers
  // ------------------------------------------------------------
  function gridKey(gx,gy){ return gx+','+gy; }
  function buildOccupancy(parts){
    const occ = new Map();
    for(const p of parts){ if(!p.dead) occ.set(gridKey(p.gx,p.gy), p); }
    return occ;
  }
  // Find first free neighbor spot (ring expanding)
  function findAttachSpot(parts){
    const occ = buildOccupancy(parts);
    // BFS rings around (0,0)
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    const visited = new Set([gridKey(0,0)]);
    const q = [[0,0]];
    let depth = 0, limit=40;
    while(q.length && limit--){
      const [cx,cy] = q.shift();
      for(const [dx,dy] of dirs){
        const nx=cx+dx, ny=cy+dy;
        const k=gridKey(nx,ny);
        if(visited.has(k)) continue;
        visited.add(k);
        if(!occ.has(k)) return {gx:nx,gy:ny};
        q.push([nx,ny]);
      }
      depth++;
    }
    // fallback (shouldn't happen)
    return {gx:0,gy:0};
  }

  function playerGunCount(ship){ return ship.parts.filter(p=>p.kind==='Gun' && !p.dead).length; }
  function playerThrusterCount(ship){ return ship.parts.filter(p=>p.kind==='Thruster' && !p.dead).length; }

  function updatePartHUD(ship){
    const count = ship.parts.filter(p=>!p.dead).length;
    setText(partCountEl, count);
  }

  // ------------------------------------------------------------
  // Attach salvage to player ship (auto-attach first free slot)
  // ------------------------------------------------------------
  function tryAttach(ship, kind){
    const spot = findAttachSpot(ship.parts);
    const part = makePart(kind, spot.gx, spot.gy, 0);
    ship.parts.push(part);
    updatePartHUD(ship);
  }

  // ------------------------------------------------------------
  // Combat utils
  // ------------------------------------------------------------
  function firePlayer(ship, t){
    // dynamic ROF and volley based on guns
    const guns = playerGunCount(ship);
    const cd = clamp(BASE_FIRE_CD - guns*PER_GUN_BONUS, 80, BASE_FIRE_CD);
    if(t < ship.fireNext) return;
    ship.fireNext = t + cd;

    const volley = clamp(1 + Math.floor(guns/1), 1, MAX_BULLETS);
    const spread = clamp(guns*0.06, 0, MAX_VOLLEY_SPREAD);
    for(let i=0;i<volley;i++){
      const bias = (i-(volley-1)/2) * (spread/(volley>1?(volley-1):1));
      const ang = ship.angle + bias;
      const bx = ship.x + Math.cos(ang)*ship.r;
      const by = ship.y + Math.sin(ang)*ship.r;
      state.entities.push(bullet(bx,by,ang,'player'));
    }
  }

  function fireEnemy(drone, target, t){
    drone.ai.fireT -= 16;
    if(drone.ai.fireT>0) return;
    const ang = Math.atan2(target.y-drone.y, target.x-drone.x) + rand(-0.12,0.12);
    const bx = drone.x + Math.cos(ang)*14;
    const by = drone.y + Math.sin(ang)*14;
    const b = {type:'bullet', owner:'enemy', x:bx, y:by, r:2,
               vx:Math.cos(ang)*ENEMY_BULLET_SPEED, vy:Math.sin(ang)*ENEMY_BULLET_SPEED,
               range:ENEMY_BULLET_RANGE};
    state.entities.push(b);
    drone.ai.fireT = 650 - Math.min(350, state.level*30);
  }

  // ------------------------------------------------------------
  // Game loop
  // ------------------------------------------------------------
  function step(){
    if(state.running) update();
    render();
    requestAnimationFrame(step);
  }

  function update(){
    const t = performance.now();
    const list = state.entities;
    const player = list.find(e=>e.type==='ship' && e.player);

    // Start screen
    if(!state.started){
      showMsg(`<h2 style="margin:0 0 8px">Captain-Forever-ish</h2>
               <div style="opacity:.9;margin-bottom:6px">‚Üê/‚Üí rotate, ‚Üë thrust, <kbd>Space</kbd> fire, <kbd>Shift</kbd> hyperspace</div>
               <div style="opacity:.9;margin-bottom:6px"><kbd>F</kbd> tractor salvage to auto-attach</div>
               <div style="opacity:.7;font-size:13px">Destroy drones for parts ¬∑ Asteroids still hurt üôÇ</div>
               <div style="opacity:.8;margin-top:8px">Press <kbd>Space</kbd> to start</div>`);
      if(state.keys.has('Space')){ hideMsg(); state.started=true; }
    }

    // Player controls
    if(player && !player.dead){
      if(state.keys.has('ArrowLeft')||state.keys.has('KeyA')) player.angle -= 0.08;
      if(state.keys.has('ArrowRight')||state.keys.has('KeyD')) player.angle += 0.08;

      // Thrust scaled by thrusters
      const thrusters = playerThrusterCount(player);
      const acc = BASE_THRUST + thrusters*THRUSTER_THRUST;
      const thrusting = state.keys.has('ArrowUp')||state.keys.has('KeyW');
      if(thrusting){
        player.vx += Math.cos(player.angle)*acc;
        player.vy += Math.sin(player.angle)*acc;
      }
      player.vx *= 0.99; player.vy *= 0.99;
      player.x += player.vx; player.y += player.vy; wrap(player);

      // Fire
      if(state.keys.has('Space')) firePlayer(player, t);

      // Hyperspace
      if(state.keys.has('ShiftLeft')||state.keys.has('ShiftRight')){
        state.keys.delete('ShiftLeft'); state.keys.delete('ShiftRight');
        player.x = rand(0,innerWidth); player.y = rand(0,innerHeight);
        player.invUntil = t + 1200;
      }
    }

    // Update asteroids
    for(const a of list){
      if(a.type==='asteroid'){
        a.x += a.vx; a.y += a.vy; a.angle += a.spin; wrap(a);
      }
    }

    // Update drones
    for(const d of list){
      if(d.type==='ship' && !d.player && !d.dead){
        // basic patrol + look-at player
        d.x += d.vx; d.y += d.vy; wrap(d);
        if(player && !player.dead){
          const ang = Math.atan2(player.y-d.y, player.x-d.x);
          // steer slightly
          d.angle += (ang - d.angle)*0.05;
          fireEnemy(d, player, t);
        }
      }
    }

    // Bullets
    for(const b of list){
      if(b.type==='bullet'){
        b.x += b.vx; b.y += b.vy; b.range -= Math.hypot(b.vx,b.vy);
        if(b.range<=0) b.dead = true; wrap(b);
      }
    }

    // Tractor salvage
    if(player && state.tractor){
      let best=null, bestd=TRACTOR_RANGE*TRACTOR_RANGE;
      for(const s of list){
        if(s.type!=='salvage' || s.dead) continue;
        const d2 = dist2(player.x,player.y,s.x,s.y);
        if(d2<bestd){ best=s; bestd=d2; }
      }
      if(best){
        const ang = Math.atan2(player.y-best.y, player.x-best.x);
        best.vx += Math.cos(ang)*TRACTOR_PULL;
        best.vy += Math.sin(ang)*TRACTOR_PULL;
        // auto attach if close
        if(bestd < ATTACH_RANGE*ATTACH_RANGE){
          tryAttach(player, best.kind);
          best.dead = true;
        }
      }
    }

    // Salvage drift
    for(const s of list){
      if(s.type==='salvage'){
        s.x += s.vx; s.y += s.vy; s.vx*=0.995; s.vy*=0.995; wrap(s);
      }
    }

    // Collisions: bullets vs asteroids/drone/player
    for(const a of list){
      if(a.type==='asteroid' && !a.dead){
        for(const b of list){
          if(b.type!=='bullet'||b.dead||b.owner!=='player') continue;
          const rr = a.r + b.r;
          if(dist2(a.x,a.y,b.x,b.y) < rr*rr){ b.dead = true; explodeAsteroid(a); }
        }
      }
    }

    // bullets vs drones
    for(const d of list){
      if(d.type==='ship' && !d.player && !d.dead){
        for(const b of list){
          if(b.type!=='bullet'||b.dead||b.owner!=='player') continue;
          const rr = 14 + b.r;
          if(dist2(d.x,d.y,b.x,b.y) < rr*rr){
            b.dead = true; killDrone(d);
          }
        }
      }
    }

    // enemy bullets vs player
    if(player && !player.dead && t>player.invUntil){
      for(const eb of list){
        if(eb.type!=='bullet' || eb.dead || eb.owner!=='enemy') continue;
        const rr = 12 + eb.r;
        if(dist2(player.x,player.y,eb.x,eb.y) < rr*rr){ eb.dead=true; killPlayer(player); break; }
      }
    }

    // player vs asteroid
    const now = t;
    if(player && !player.dead && now>player.invUntil){
      for(const a of list){
        if(a.type!=='asteroid'||a.dead) continue;
        const rr = a.r + 12;
        if(dist2(a.x,a.y,player.x,player.y) < rr*rr){ killPlayer(player); break; }
      }
    }

    // Particles
    for(const p of state.particles){ p.x+=p.vx; p.y+=p.vy; p.life--; wrap(p); }
    for(let i=state.particles.length-1;i>=0;i--) if(state.particles[i].life<=0) state.particles.splice(i,1);

    // Cleanup
    for(let i=list.length-1;i>=0;i--) if(list[i].dead) list.splice(i,1);

    // Progression
    // If no asteroids and drones left ‚Üí level++
    const hasAst = list.some(e=>e.type==='asteroid');
    const hasDrone = list.some(e=>e.type==='ship' && !e.player && !e.dead);
    if(!hasAst && !hasDrone){
      state.level++; spawnLevel();
    }
  }

  // ------------------------------------------------------------
  // Events
  // ------------------------------------------------------------
  function explodeAsteroid(a){
    a.dead=true; state.kills++;
    const add = a.size===3?20:a.size===2?50:100;
    state.score += add; pushBest(); sparkle(a.x,a.y,16,'rgba(255,255,255,.9)');
    if(a.size>1){
      for(let i=0;i<2;i++){
        const c = asteroid(a.x,a.y,a.size-1);
        const ang = rand(0,TAU); const sp = rand(0.5,1.2);
        c.vx += Math.cos(ang)*sp; c.vy += Math.sin(ang)*sp;
        state.entities.push(c);
      }
    }
  }

  function killDrone(d){
    d.dead = true;
    state.score += 120; pushBest();
    sparkle(d.x,d.y,24,'rgba(87,230,193,.9)');
    // drop 1‚Äì2 salvage parts
    const drops = 1 + (Math.random()<0.4?1:0);
    const bag = ['Girder','Thruster','Gun'];
    for(let i=0;i<drops;i++){
      const kind = bag[Math.floor(Math.random()*bag.length)];
      state.entities.push(salvage(kind, d.x+rand(-6,6), d.y+rand(-6,6)));
    }
  }

  function killPlayer(player){
    player.dead=true; state.lives--; setText(livesEl,state.lives);
    sparkle(player.x,player.y,36,'rgba(255,107,107,.95)');
    if(state.lives<0){
      state.running=false;
      showMsg(`<h3 style="margin:0 0 8px">Game Over</h3>
               <div style="margin-bottom:8px">Score ${state.score} ¬∑ Best ${state.best}</div>
               <div><kbd>R</kbd> to restart</div>`);
    } else {
      setTimeout(()=>{
        const s = makeShip(innerWidth/2, innerHeight/2, true);
        state.entities.push(s);
        s.invUntil = performance.now()+1800;
        updatePartHUD(s);
      }, 900);
    }
  }

  function pushBest(){
    setText(scoreEl, state.score);
    if(state.score>state.best){ state.best=state.score; setText(bestEl,state.best); localStorage.setItem('cfish_best', state.best); }
  }

  function sparkle(x,y,n,color){
    for(let i=0;i<n;i++){
      const a = rand(0,TAU), sp=rand(0.7,2.4);
      state.particles.push(particle(x,y,Math.cos(a)*sp,Math.sin(a)*sp, 40+Math.random()*20, color));
    }
  }

  // ------------------------------------------------------------
  // Render
  // ------------------------------------------------------------
  function render(){
    ctx.clearRect(0,0,innerWidth,innerHeight);

    // cheap starfield
    ctx.save(); ctx.globalAlpha=.15;
    for(let i=0;i<80;i++){
      const x = (i*137.5 + performance.now()*0.01) % innerWidth;
      const y = (i*91.7 + i*13) % innerHeight;
      ctx.fillRect(x,y,1,1);
    }
    ctx.restore();

    // particles
    for(const p of state.particles){
      ctx.globalAlpha = clamp(p.life/60,0,1);
      ctx.fillStyle = p.color || 'white';
      ctx.fillRect(p.x,p.y,2,2);
      ctx.globalAlpha=1;
    }

    for(const e of state.entities){
      switch(e.type){
        case 'ship':
          drawShip(e);
          if(e.player) drawShipGrid(e);
          break;
        case 'asteroid': drawAsteroid(e); break;
        case 'bullet': drawBullet(e); break;
        case 'salvage': drawSalvage(e); break;
      }
    }
  }

  function drawShip(s){
    ctx.save();
    ctx.translate(s.x,s.y);
    // Base core ring (invincibility blink)
    const inv = performance.now() < s.invUntil;
    if(inv && Math.floor(performance.now()/120)%2===0) ctx.globalAlpha = 0.35;

    // Draw parts
    for(const p of s.parts){
      if(p.dead) continue;
      ctx.save();
      ctx.translate(p.gx*GRID, p.gy*GRID);
      ctx.rotate(p.rot || 0);
      PartDefs[p.kind].draw(ctx);
      ctx.restore();
    }

    // Facing indicator (nose)
    ctx.rotate(s.angle);
    ctx.strokeStyle = 'rgba(231,236,239,.5)';
    ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(20,0); ctx.stroke();
    ctx.restore();
  }

  function drawShipGrid(s){
    // subtle mount dots to hint attachment lattice
    ctx.save();
    ctx.translate(s.x,s.y);
    ctx.globalAlpha = .20;
    const R = 3; // grid rings to show
    for(let gx=-R; gx<=R; gx++){
      for(let gy=-R; gy<=R; gy++){
        if(gx===0 && gy===0) continue;
        if(Math.abs(gx)+Math.abs(gy)===1 || Math.abs(gx)+Math.abs(gy)===2){ // show near slots
          ctx.fillStyle = '#e7ecef';
          ctx.fillRect(gx*GRID-1, gy*GRID-1, 2, 2);
        }
      }
    }
    ctx.restore();
  }

  function drawAsteroid(a){
    ctx.save();
    ctx.translate(a.x,a.y); ctx.rotate(a.angle);
    ctx.strokeStyle = 'rgba(231,236,239,.95)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const n = a.irregular.length; const R=a.r;
    for(let i=0;i<n;i++){
      const ang = (i/n)*TAU;
      const rr = R * a.irregular[i];
      const x = Math.cos(ang)*rr, y = Math.sin(ang)*rr;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath(); ctx.stroke();
    ctx.restore();
  }

  function drawBullet(b){
    ctx.beginPath(); ctx.arc(b.x,b.y,2,0,TAU);
    ctx.fillStyle = b.owner==='player' ? '#57e6c1' : '#ff6b6b'; ctx.fill();
  }

  function drawSalvage(sv){
    ctx.save();
    ctx.translate(sv.x,sv.y);
    ctx.globalAlpha=.95;
    ctx.scale(0.9,0.9);
    PartDefs[sv.kind].draw(ctx);
    ctx.restore();
  }

  // ------------------------------------------------------------
  // Boot
  // ------------------------------------------------------------
  reset();
  step();

})();
</script>
</body>
</html>
