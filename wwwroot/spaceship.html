<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2D Kerbal-Style Orbit Game – Helion System</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    color: #fff;
  }
  #game {
    display: block;
    background: radial-gradient(circle at 50% 130%, #001018, #000000 65%, #02020a);
  }
  #overlay {
    position: fixed;
    top: 8px;
    left: 8px;
    font-size: 14px;
    text-shadow: 0 0 4px #000;
    pointer-events: none;
    white-space: pre;
  }
  #help {
    position: fixed;
    bottom: 8px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    text-shadow: 0 0 4px #000;
    text-align: center;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"></div>
<div id="help">
  Controls: ← → rotate · ↑ thrust / takeoff · SPACE stage · R reset · [ / ] time warp · - / = zoom · F follow/free<br>
  Mouse wheel zooms · Drag to pan (free cam) · Dashed path = coast-only trajectory under moving Helion + planet gravity.<br>
  Transfer planner: 1–8 select target planet · P plan Helion-centered Hohmann (inner → outer only)
</div>

<script>
(function () {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const overlay = document.getElementById("overlay");
  const SAFE_COORD = 1_000_000;
  const SAFE_ORBIT_RADIUS_PX = 20000;

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  // --- Time warp ---------------------------------------------------------
  let timeScale = 1;
  const MIN_WARP = 0.1;
  const MAX_WARP = 500;

  // --- Camera: zoom, pan, follow ----------------------------------------
  let cameraZoom = 8;            // higher default to keep planets visible with big system
  const MIN_ZOOM = 0.25;
  const MAX_ZOOM = 1000;         // allow ~1000x zoom

  let cameraX = 0;
  let cameraY = 0;
  let cameraFollow = true; // follow ship by default

  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartCamX = 0;
  let dragStartCamY = 0;

  // --- Transfer planner state -------------------------------------------
  let transferTargetIndex = 3;  // default target
  let transferPlan = null;      // populated by createTransferPlan()

  function normalizeAngle(a) {
    const twoPi = Math.PI * 2;
    a = a % twoPi;
    if (a < 0) a += twoPi;
    return a;
  }

  function smallestAngleDiff(target, current) {
    const t = normalizeAngle(target);
    const c = normalizeAngle(current);
    let d = t - c;
    if (d > Math.PI) d -= 2 * Math.PI;
    if (d < -Math.PI) d += 2 * Math.PI;
    return d;
  }

  function setTransferTarget(index) {
    if (index <= 0 || index >= BODIES.length) return;
    transferTargetIndex = index;
    transferPlan = null;
    if (state) {
      state.message = "Transfer target: " + BODIES[index].name;
    }
  }

  // --- Celestial bodies: Helion + orbiting planets ----------------------
  // We'll blow up orbital radii by this factor to make a more
  // "solar-system-ish" scale without changing planet sizes.
  const ORBIT_SCALE = 50;

  const BODIES = [
    {
      // Central star
      name: "Helion",
      x: 0,
      y: 0,
      radius: 1200,
      // Kept high for nice orbital speeds; not literal solar GM.
      mu: 4.0176e7,
      atmosphere: 0,
      colors: { inner: "#fff7b3", mid: "#ffcc33", outer: "#d47a1a" }
    },
    {
      // Homeworld – Earth-like (~1 g)
      name: "Astraia",
      orbitalRadius: 15000 * ORBIT_SCALE,
      angle: 0,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 600,
      // μ = g * R^2 with g ≈ 9.81 m/s² = 0.00981 km/s²
      mu: 3531.6,
      atmosphere: 40,
      colors: { inner: "#08384f", mid: "#0a5b32", outer: "#021016" }
    },
    {
      // Rocky twilight world (~0.38 g, Mars-ish)
      name: "Nyxos",
      orbitalRadius: 21000 * ORBIT_SCALE,
      angle: 1.4,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 300,
      // g ≈ 3.71 m/s² => 0.00371 km/s²
      mu: 333.9,
      atmosphere: 0,
      colors: { inner: "#30213b", mid: "#5b3e7a", outer: "#150d1f" }
    },
    {
      // Ocean world (slightly > 1 g)
      name: "Thalassa",
      orbitalRadius: 28000 * ORBIT_SCALE,
      angle: -2.0,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 700,
      // g ≈ 11.5 m/s² => 0.0115 km/s²
      mu: 5635.0,
      atmosphere: 60,
      colors: { inner: "#0b3b6f", mid: "#1579c1", outer: "#031322" }
    },
    {
      // Ember-toned desert (~0.8 g)
      name: "Emberon",
      orbitalRadius: 36000 * ORBIT_SCALE,
      angle: 2.6,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 260,
      // g ≈ 8.0 m/s² => 0.008 km/s²
      mu: 540.8,
      atmosphere: 20,
      colors: { inner: "#5a2610", mid: "#c0551c", outer: "#280904" }
    },
    {
      // Icy mirror world (~0.6 g)
      name: "Mirr",
      orbitalRadius: 48000 * ORBIT_SCALE,
      angle: -1.1,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 400,
      // g ≈ 6.0 m/s² => 0.006 km/s²
      mu: 960.0,
      atmosphere: 10,
      colors: { inner: "#d0e7ff", mid: "#7ca0c8", outer: "#1b2635" }
    },
    {
      // Dark outer rock (~0.16 g)
      name: "Umbral",
      orbitalRadius: 65000 * ORBIT_SCALE,
      angle: 0.9,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 320,
      // g ≈ 1.6 m/s² => 0.0016 km/s²
      mu: 163.84,
      atmosphere: 0,
      colors: { inner: "#262b33", mid: "#4b5663", outer: "#090b0f" }
    },
    {
      // Gas giant (~Jupiter-ish)
      name: "Zephyrus",
      orbitalRadius: 90000 * ORBIT_SCALE,
      angle: -2.5,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 1000,
      // g ≈ 24.8 m/s² => 0.0248 km/s²
      mu: 24800.0,
      atmosphere: 150,
      colors: { inner: "#30406b", mid: "#5b7fc0", outer: "#101525" }
    },
    {
      // Remote ice giant
      name: "Noxshade",
      orbitalRadius: 130000 * ORBIT_SCALE,
      angle: 0.3,
      orbitalSpeed: 0,
      x: 0, y: 0,
      radius: 800,
      // g ≈ 11.0 m/s² => 0.011 km/s²
      mu: 7040.0,
      atmosphere: 120,
      colors: { inner: "#485f78", mid: "#7ca3d0", outer: "#0b1018" }
    }
  ];

  const SUN = BODIES[0];
  const MAIN_BODY = BODIES[1]; // launch from Astraia

  function computeSystemRadius() {
    let max = 0;
    for (const b of BODIES) {
      let d;
      if (typeof b.orbitalRadius === "number") {
        d = b.orbitalRadius + b.radius * 2;
      } else {
        d = Math.hypot(b.x - SUN.x, b.y - SUN.y) + b.radius * 2;
      }
      if (d > max) max = d;
    }
    return max;
  }

  const SYSTEM_RADIUS = computeSystemRadius();
  const SYSTEM_ESCAPE_RADIUS = SYSTEM_RADIUS * 2.5;

  // --- Starfield ---------------------------------------------------------
  const STAR_COUNT = 600;
  const STAR_FIELD_RADIUS = SYSTEM_RADIUS * 4;
  const STARS = [];

  (function initStars() {
    STARS.length = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      // Polar distribution biased slightly toward center
      const r = STAR_FIELD_RADIUS * Math.sqrt(Math.random());
      const theta = Math.random() * Math.PI * 2;
      STARS.push({
        x: Math.cos(theta) * r,
        y: Math.sin(theta) * r,
        brightness: Math.random(),          // 0–1 for alpha variation
        size: 0.5 + Math.random()          // relative size factor
      });
    }
  })();

  function initOrbits() {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        body.orbitalSpeed = Math.sqrt(SUN.mu / Math.pow(body.orbitalRadius, 3)) * 0.6;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  function updateBodyPositions(dt) {
    for (let i = 1; i < BODIES.length; i++) {
      const body = BODIES[i];
      if (typeof body.orbitalRadius === "number") {
        body.angle += body.orbitalSpeed * dt;
        body.x = SUN.x + Math.cos(body.angle) * body.orbitalRadius;
        body.y = SUN.y + Math.sin(body.angle) * body.orbitalRadius;
      }
    }
  }

  initOrbits();

  function getPrimaryBody(x, y) {
    let best = BODIES[0];
    let bestDist2 = (x - best.x) * (x - best.x) + (y - best.y) * (y - best.y);
    for (let i = 1; i < BODIES.length; i++) {
      const b = BODIES[i];
      const dx = x - b.x;
      const dy = y - b.y;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestDist2) {
        best = b;
        bestDist2 = d2;
      }
    }
    return best;
  }

  // --- Rocket & stages ---------------------------------------------------
  const CORE_MASS = 4;
  const FUEL_DENSITY = 0.01;

  const STAGES_TEMPLATE = [
    {
      name: "Booster",
      maxFuel: 12000,
      fuel: 12000,
      thrust: 32,     // 1/10 original
      dryMass: 6
    },
    {
      name: "Orbiter",
      maxFuel: 7000,
      fuel: 7000,
      thrust: 10,     // 1/10 original
      dryMass: 3
    }
  ];

  const ROT_SPEED = (Math.PI / 180) * 60; // rad/s

  let state;

  function cloneStages() {
    return STAGES_TEMPLATE.map(s => ({ ...s }));
  }

  function resetGame() {
    initOrbits();

    const mb = MAIN_BODY;

    const dxSun = mb.x - SUN.x;
    const dySun = mb.y - SUN.y;
    const rPlanet = Math.hypot(dxSun, dySun) || 1;
    const ux = dxSun / rPlanet;
    const uy = dySun / rPlanet;

    const surfaceAltitude = mb.radius + 5;
    const rocketX = mb.x + ux * surfaceAltitude;
    const rocketY = mb.y + uy * surfaceAltitude;

    const omega = mb.orbitalSpeed;
    const vMag = omega * rPlanet;
    const tx = -uy;
    const ty = ux;
    const rocketVx = vMag * tx;
    const rocketVy = vMag * ty;

    const normalAngle = Math.atan2(rocketY - mb.y, rocketX - mb.x);

    state = {
      rocket: {
        x: rocketX,
        y: rocketY,
        vx: rocketVx,
        vy: rocketVy,
        angle: normalAngle,
        thrusting: false
      },
      stages: cloneStages(),
      currentStageIndex: 0,
      crashed: false,
      landed: true,
      landedBody: mb,
      landedAltitude: surfaceAltitude,
      landedNormalAngle: normalAngle,
      escaped: false,
      orbitStable: false,
      orbitBound: false,
      orbitEscaping: false,
      orbitPeriod: null,
      lastPeriapsis: null,
      primaryBody: mb,
      orbitElements: null,
      message: "On " + mb.name + "'s surface. Hold ↑ to lift off. Low thrust = long burns.",
      trail: [],
      predictedPath: [],
      time: 0
    };

    cameraFollow = true;
    cameraX = state.rocket.x;
    cameraY = state.rocket.y;

    transferPlan = null;
  }

  resetGame();

  function currentStage() {
    return state.stages[state.currentStageIndex] || null;
  }

  function rocketMass() {
    let mass = CORE_MASS;
    for (let i = state.currentStageIndex; i < state.stages.length; i++) {
      const s = state.stages[i];
      mass += s.dryMass + s.fuel * FUEL_DENSITY;
    }
    return mass;
  }

  // --- Input -------------------------------------------------------------
  const keys = {};
  window.addEventListener("keydown", e => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) {
      e.preventDefault();
    }
    keys[e.code] = true;

    if (e.code === "Space") {
      stageSeparation();
    }
    if (e.code === "KeyR") {
      resetGame();
    }

    if (e.code === "BracketLeft") {
      timeScale = Math.max(MIN_WARP, timeScale / 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }
    if (e.code === "BracketRight") {
      timeScale = Math.min(MAX_WARP, timeScale * 2);
      state.message = "Time warp: " + timeScale.toFixed(2) + "x";
    }

    if (e.code === "Minus") {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / 1.2);
    }
    if (e.code === "Equal") {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * 1.2);
    }

    if (e.code === "KeyF") {
      cameraFollow = !cameraFollow;
      if (cameraFollow) {
        cameraX = state.rocket.x;
        cameraY = state.rocket.y;
        state.message = "Camera: follow ship";
      } else {
        state.message = "Camera: free";
      }
    }

    if (e.code === "Digit1") setTransferTarget(1);
    if (e.code === "Digit2") setTransferTarget(2);
    if (e.code === "Digit3") setTransferTarget(3);
    if (e.code === "Digit4") setTransferTarget(4);
    if (e.code === "Digit5") setTransferTarget(5);
    if (e.code === "Digit6") setTransferTarget(6);
    if (e.code === "Digit7") setTransferTarget(7);
    if (e.code === "Digit8") setTransferTarget(8);

    if (e.code === "KeyP") {
      createTransferPlan();
    }
  });

  window.addEventListener("keyup", e => {
    keys[e.code] = false;
  });

  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    if (e.deltaY < 0) {
      cameraZoom = Math.min(MAX_ZOOM, cameraZoom * 1.1);
    } else if (e.deltaY > 0) {
      cameraZoom = Math.max(MIN_ZOOM, cameraZoom / 1.1);
    }
  }, { passive: false });

  function getScale() {
    const w = canvas.width;
    const h = canvas.height;
    const baseScale = Math.min(w, h) / (SYSTEM_RADIUS * 2);
    return baseScale * cameraZoom;
  }

  canvas.addEventListener("mousedown", e => {
    if (e.button !== 0) return;
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartCamX = cameraX;
    dragStartCamY = cameraY;
    cameraFollow = false;
    state.message = "Camera: free (drag to pan)";
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
  });

  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    const scale = getScale();
    cameraX = dragStartCamX - dx / scale;
    cameraY = dragStartCamY + dy / scale;
  });

  function stageSeparation() {
    if (state.crashed || state.escaped) return;
    if (state.currentStageIndex >= state.stages.length - 1) return;
    state.currentStageIndex++;
    state.message = "Stage separated!";
  }

  // --- Physics step ------------------------------------------------------
  function update(dt) {
    state.time += dt;
    updateBodyPositions(dt);

    const rocket = state.rocket;
    const stage = currentStage();
    if (!rocket) return;

    if (state.landed && !state.crashed && !state.escaped) {
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        rocket.angle += ROT_SPEED * dt;
      }
      if (keys["ArrowRight"] || keys["KeyD"]) {
        rocket.angle -= ROT_SPEED * dt;
      }

      const body = state.landedBody || getPrimaryBody(rocket.x, rocket.y);
      state.landedBody = body;

      let bodyVx = 0;
      let bodyVy = 0;
      if (typeof body.orbitalRadius === "number") {
        const rOrbit = body.orbitalRadius;
        const omega = body.orbitalSpeed;
        const angle = body.angle;
        bodyVx = -Math.sin(angle) * rOrbit * omega;
        bodyVy =  Math.cos(angle) * rOrbit * omega;
      }

      const alt = state.landedAltitude != null ? state.landedAltitude : body.radius;
      const normalAngle =
        state.landedNormalAngle != null
          ? state.landedNormalAngle
          : Math.atan2(rocket.y - body.y, rocket.x - body.x);

      rocket.x = body.x + Math.cos(normalAngle) * alt;
      rocket.y = body.y + Math.sin(normalAngle) * alt;
      rocket.vx = bodyVx;
      rocket.vy = bodyVy;

      const wantsThrust = stage && stage.fuel > 0 && (keys["ArrowUp"] || keys["KeyW"]);
      rocket.thrusting = !!wantsThrust;

      if (cameraFollow) {
        cameraX = rocket.x;
        cameraY = rocket.y;
      }

      if (!wantsThrust) {
        return;
      } else {
        state.landed = false;
        state.landedBody = null;
        state.message = "Liftoff from " + body.name + "!";
      }
    }

    if (state.crashed || state.escaped) {
      rocket.thrusting = false;
      return;
    }

    if (keys["ArrowLeft"] || keys["KeyA"]) {
      rocket.angle += ROT_SPEED * dt;
    }
    if (keys["ArrowRight"] || keys["KeyD"]) {
      rocket.angle -= ROT_SPEED * dt;
    }

    if (stage && stage.fuel > 0) {
      rocket.thrusting = (keys["ArrowUp"] || keys["KeyW"]);
    } else {
      rocket.thrusting = false;
    }

    let ax = 0;
    let ay = 0;

    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      const gravAccMag = -body.mu / (r * r);
      ax += gravAccMag * (dx / r);
      ay += gravAccMag * (dy / r);
    }

    if (rocket.thrusting && stage && stage.fuel > 0) {
      const mass = rocketMass();
      const thrustAcc = stage.thrust / mass;
      const tx = Math.cos(rocket.angle) * thrustAcc;
      const ty = Math.sin(rocket.angle) * thrustAcc;
      ax += tx;
      ay += ty;

      const fuelUseRate = 25;
      const dfuel = fuelUseRate * dt;
      stage.fuel = Math.max(0, stage.fuel - dfuel);
      if (stage.fuel <= 0) {
        rocket.thrusting = false;
        state.message = stage.name + " out of fuel.";
      }
    }

    rocket.vx += ax * dt;
    rocket.vy += ay * dt;
    rocket.x += rocket.vx * dt;
    rocket.y += rocket.vy * dt;

    if (state.time % 0.02 < dt) {
      state.trail.push({ x: rocket.x, y: rocket.y });
      if (state.trail.length > 500) {
        state.trail.shift();
      }
    }

    let collidedBody = null;
    let minDist = Infinity;
    for (const body of BODIES) {
      const dx = rocket.x - body.x;
      const dy = rocket.y - body.y;
      const r = Math.hypot(dx, dy);
      if (r <= body.radius && r < minDist) {
        minDist = r;
        collidedBody = body;
      }
    }

    const speed = Math.hypot(rocket.vx, rocket.vy);

    if (collidedBody) {
      if (collidedBody === SUN || speed >= 3) {
        state.crashed = true;
        state.message = "CRASH into " + collidedBody.name + "! Press R to retry.";
        return;
      } else {
        state.landed = true;
        state.landedBody = collidedBody;
        state.landedAltitude = collidedBody.radius;
        state.landedNormalAngle = Math.atan2(rocket.y - collidedBody.y, rocket.x - collidedBody.x);
        rocket.vx = 0;
        rocket.vy = 0;
        state.message = "Nice landing on " + collidedBody.name + "! Hold ↑ to take off or R to reset.";
        return;
      }
    }

    classifyOrbit();

    if (cameraFollow) {
      cameraX = rocket.x;
      cameraY = rocket.y;
    }
  }

  // --- Orbit classification ----------------------------------------------
  function classifyOrbit() {
    const rocket = state.rocket;
    const body = getPrimaryBody(rocket.x, rocket.y);
    state.primaryBody = body;

    const rx = rocket.x - body.x;
    const ry = rocket.y - body.y;
    const r = Math.hypot(rx, ry);

    let bodyVx = 0;
    let bodyVy = 0;
    if (typeof body.orbitalRadius === "number") {
      const rOrbit = body.orbitalRadius;
      const omega = body.orbitalSpeed;
      const angle = body.angle;
      bodyVx = -Math.sin(angle) * rOrbit * omega;
      bodyVy =  Math.cos(angle) * rOrbit * omega;
    }

    const vxRel = rocket.vx - bodyVx;
    const vyRel = rocket.vy - bodyVy;
    const v2 = vxRel * vxRel + vyRel * vyRel;
    const mu = body.mu;

    const specificEnergy = 0.5 * v2 - mu / r;

    state.orbitStable = false;
    state.orbitBound = false;
    state.orbitEscaping = false;
    state.orbitPeriod = null;
    state.orbitElements = null;

    if (specificEnergy > 0) {
      state.orbitEscaping = true;
      state.lastPeriapsis = null;
    } else if (specificEnergy < 0) {
      state.orbitBound = true;

      const h = rx * vyRel - ry * vxRel;
      const a = -mu / (2 * specificEnergy);
      let e2 = 1 - (h * h) / (a * mu);
      if (e2 < 0) e2 = 0;
      const e = Math.sqrt(e2);
      const rp = a * (1 - e);

      state.lastPeriapsis = rp - body.radius;
      state.orbitPeriod = 2 * Math.PI * Math.sqrt(Math.pow(a, 3) / mu);

      if (isFinite(a) && e >= 0) {
        const rdotv = rx * vxRel + ry * vyRel;
        const factor1 = (v2 - mu / r) / mu;
        const factor2 = rdotv / mu;

        let ex = factor1 * rx - factor2 * vxRel;
        let ey = factor1 * ry - factor2 * vyRel;
        let emag = Math.hypot(ex, ey);

        if (emag < 1e-6) {
          ex = rx / r;
          ey = ry / r;
          emag = 1;
        }

        const ehatx = ex / emag;
        const ehaty = ey / emag;

        const rpRadius = a * (1 - e);
        const raRadius = a * (1 + e);

        const periX = body.x + ehatx * rpRadius;
        const periY = body.y + ehaty * rpRadius;
        const apoX  = body.x - ehatx * raRadius;
        const apoY  = body.y - ehaty * raRadius;

        state.orbitElements = {
          bodyName: body.name,
          bodyX: body.x,
          bodyY: body.y,
          periRadius: rpRadius,
          apoRadius: raRadius,
          periX,
          periY,
          apoX,
          apoY
        };
      }

      const atmo = body.atmosphere || 0;
      if (rp > body.radius + atmo) {
        state.orbitStable = true;
        if (!state.message.startsWith("Stable orbit around")) {
          state.message = "Stable orbit around " + body.name + " achieved!";
        }
      }
    } else {
      state.lastPeriapsis = null;
    }

    const distFromOrigin = Math.hypot(rocket.x, rocket.y);
    if (!state.escaped && distFromOrigin > SYSTEM_ESCAPE_RADIUS) {
      state.escaped = true;
      state.message = "You escaped the system! Press R to restart.";
    }
  }

  // --- Hohmann transfer planner -----------------------------------------
  function createTransferPlan() {
    const rocket = state.rocket;
    if (!rocket) return;

    const origin = state.primaryBody || getPrimaryBody(rocket.x, rocket.y);
    const originIndex = BODIES.indexOf(origin);
    const destIndex = transferTargetIndex;

    if (originIndex <= 0 || destIndex <= 0) {
      state.message = "Planner: origin and destination must be planets (not Helion).";
      transferPlan = null;
      return;
    }

    const dest = BODIES[destIndex];

    if (typeof origin.orbitalRadius !== "number" || typeof dest.orbitalRadius !== "number") {
      state.message = "Planner: both bodies must orbit Helion.";
      transferPlan = null;
      return;
    }

    const r1 = origin.orbitalRadius;
    const r2 = dest.orbitalRadius;

    if (r2 <= r1) {
      state.message = "Planner: only inner → outer Hohmann supported.";
      transferPlan = null;
      return;
    }

    const mu = SUN.mu;

    const a_t = (r1 + r2) / 2;
    const tTransfer = Math.PI * Math.sqrt((a_t * a_t * a_t) / mu);

    const v1 = Math.sqrt(mu / r1);
    const v2 = Math.sqrt(mu / r2);

    const vTrans1 = Math.sqrt(mu * (2 / r1 - 1 / a_t));
    const vTrans2 = Math.sqrt(mu * (2 / r2 - 1 / a_t));

    const deltaV1 = vTrans1 - v1;
    const deltaV2 = v2 - vTrans2;

    const omegaOrigin = origin.orbitalSpeed;
    const omegaDest = dest.orbitalSpeed;

    const phaseTarget = normalizeAngle(Math.PI - omegaDest * tTransfer);
    const periAngle = origin.angle;

    transferPlan = {
      originIndex,
      destIndex,
      r1,
      r2,
      a_t,
      tTransfer,
      deltaV1,
      deltaV2,
      phaseTarget,
      periAngle,
      omegaOrigin,
      omegaDest
    };

    state.message = "Planner: Hohmann " + origin.name + " → " + dest.name + " created. Burn when phase error ≈ 0°.";
  }

  // --- Predictive path ---------------------------------------------------
  function updatePredictedPath() {
    const rocket = state.rocket;
    if (!rocket || state.crashed || state.landed) {
      state.predictedPath = [];
      return;
    }

    let x = rocket.x;
    let y = rocket.y;
    let vx = rocket.vx;
    let vy = rocket.vy;

    const predicted = [];

    const dt = 0.05;
    const steps = 3600;
    const maxRadius = SYSTEM_ESCAPE_RADIUS * 1.5;

    const predBodies = BODIES.map(b => ({
      name: b.name,
      x: b.x,
      y: b.y,
      radius: b.radius,
      mu: b.mu,
      atmosphere: b.atmosphere || 0,
      orbitalRadius: b.orbitalRadius,
      angle: b.angle,
      orbitalSpeed: b.orbitalSpeed
    }));

    const predSun = predBodies[0];

    for (let i = 0; i < steps; i++) {
      for (let j = 1; j < predBodies.length; j++) {
        const pb = predBodies[j];
        if (typeof pb.orbitalRadius === "number" && typeof pb.orbitalSpeed === "number") {
          pb.angle += pb.orbitalSpeed * dt;
          pb.x = predSun.x + Math.cos(pb.angle) * pb.orbitalRadius;
          pb.y = predSun.y + Math.sin(pb.angle) * pb.orbitalRadius;
        }
      }

      let hit = false;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        if (r <= body.radius) {
          hit = true;
          break;
        }
      }
      if (hit) break;

      const distFromOrigin = Math.hypot(x, y);
      if (distFromOrigin > maxRadius) break;

      let ax = 0;
      let ay = 0;
      for (const body of predBodies) {
        const dx = x - body.x;
        const dy = y - body.y;
        const r = Math.hypot(dx, dy);
        const gravAccMag = -body.mu / (r * r);
        ax += gravAccMag * (dx / r);
        ay += gravAccMag * (dy / r);
      }

      vx += ax * dt;
      vy += ay * dt;
      x += vx * dt;
      y += vy * dt;

      if (i % 8 === 0) {
        predicted.push({ x, y });
      }
    }

    state.predictedPath = predicted;
  }

  // --- Drawing -----------------------------------------------------------
  function draw() {
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const scale = getScale();
    const centerX = w / 2;
    const centerY = h / 2;

    function worldToScreen(x, y) {
      return {
        x: centerX + (x - cameraX) * scale,
        y: centerY - (y - cameraY) * scale
      };
    }

    function screenWithinBounds(p) {
      return (
        p.x > -SAFE_COORD && p.x < SAFE_COORD &&
        p.y > -SAFE_COORD && p.y < SAFE_COORD
      );
    }

    // --- Starfield background (world-space; reacts to pan & zoom) -------
    ctx.save();
    const baseStarSize = Math.max(0.5, Math.min(3, cameraZoom * 0.1)); // scales with zoom
    for (const s of STARS) {
      const p = worldToScreen(s.x, s.y);
      // Slight padding; no need to draw way off-screen
      if (p.x < -50 || p.x > w + 50 || p.y < -50 || p.y > h + 50) continue;
      const alpha = 0.3 + s.brightness * 0.7;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, baseStarSize * s.size, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
    }
    ctx.restore();

    // Orbital paths (Helion-centered dashed circles)
    ctx.save();
    ctx.strokeStyle = "rgba(255, 255, 255, 0.12)";
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 6]);

    const sunScreen = worldToScreen(SUN.x, SUN.y);
    const maxOrbitScreenRadius = Math.max(w, h) * 1.2;

    for (const body of BODIES) {
      if (typeof body.orbitalRadius === "number") {
        const rPx = body.orbitalRadius * scale;
        if (rPx < 1 || rPx > SAFE_ORBIT_RADIUS_PX || rPx > maxOrbitScreenRadius) continue;
        ctx.beginPath();
        ctx.arc(sunScreen.x, sunScreen.y, rPx, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    ctx.restore();

    // Hohmann transfer orbit (if any)
    if (transferPlan) {
      const { r1, r2, a_t, periAngle } = transferPlan;
      const maxR = Math.max(r1, r2);
      const maxRPx = maxR * scale;
      const maxTransferRadius = Math.max(w, h) * 1.2;

      if (maxRPx < SAFE_ORBIT_RADIUS_PX && maxRPx < maxTransferRadius) {
        const eTran = (r2 - r1) / (r2 + r1);

        ctx.save();
        ctx.strokeStyle = "rgba(0, 255, 255, 0.8)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 120;
        for (let i = 0; i <= steps; i++) {
          const f = (Math.PI * i) / steps;
          const r = a_t * (1 - eTran * eTran) / (1 + eTran * Math.cos(f));
          const theta = periAngle + f;

          const x = SUN.x + r * Math.cos(theta);
          const y = SUN.y + r * Math.sin(theta);

          const p = worldToScreen(x, y);
          const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      }
    }

    // Bodies: Helion + planets
    for (const body of BODIES) {
      ctx.save();
      const screen = worldToScreen(body.x, body.y);
      const rPx = body.radius * scale;

      const margin = Math.max(w, h) * 0.6 + rPx;
      if (screen.x < -margin || screen.x > w + margin ||
          screen.y < -margin || screen.y > h + margin) {
        ctx.restore();
        continue;
      }

      const grd = ctx.createRadialGradient(
        screen.x - rPx * 0.3,
        screen.y - rPx * 0.3,
        rPx * 0.2,
        screen.x,
        screen.y,
        rPx
      );
      const c = body.colors;
      grd.addColorStop(0, c.inner);
      grd.addColorStop(0.5, c.mid);
      grd.addColorStop(1, c.outer);

      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, rPx, 0, Math.PI * 2);
      ctx.fill();

      const atmo = body.atmosphere || 0;
      if (atmo > 0) {
        const atmoRadiusPx = (body.radius + atmo) * scale;
        if (atmoRadiusPx < SAFE_ORBIT_RADIUS_PX) {
          ctx.strokeStyle = "rgba(80,200,255,0.25)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(screen.x, screen.y, atmoRadiusPx, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      ctx.fillStyle = "#ffffff";
      ctx.font = "11px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(body.name, screen.x, screen.y + rPx + 4);
      ctx.restore();
    }

    // Predicted trajectory
    if (state.predictedPath && state.predictedPath.length > 1) {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.predictedPath.length; i++) {
        const p = worldToScreen(state.predictedPath[i].x, state.predictedPath[i].y);
        const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Trail
    if (state.trail.length > 1) {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(180,180,255,0.6)";
      ctx.beginPath();
      let started = false;
      let prevOnScreen = false;

      for (let i = 0; i < state.trail.length; i++) {
        const p = worldToScreen(state.trail[i].x, state.trail[i].y);
        const onScreen = (p.x >= -50 && p.x <= w + 50 && p.y >= -50 && p.y <= h + 50);
        if (!onScreen) {
          prevOnScreen = false;
          continue;
        }
        if (!started) {
          ctx.moveTo(p.x, p.y);
          started = true;
        } else if (!prevOnScreen) {
          ctx.moveTo(p.x, p.y);
        } else {
          ctx.lineTo(p.x, p.y);
        }
        prevOnScreen = true;
      }
      ctx.stroke();
      ctx.restore();
    }

    // Apsis markers + analytic orbit ellipse for current bound orbit
    if (state.orbitBound && state.orbitElements) {
      const oe = state.orbitElements;

      const periScreen = worldToScreen(oe.periX, oe.periY);
      const apoScreen  = worldToScreen(oe.apoX, oe.apoY);
      const bodyScreen = worldToScreen(oe.bodyX, oe.bodyY);

      // --- Orbit ellipse line (osculating orbit around primary body) ---
      (function drawOrbitEllipse() {
        const rp = oe.periRadius;
        const ra = oe.apoRadius;
        const a  = (rp + ra) / 2;
        if (!isFinite(a) || a <= 0) return;

        let e = 1 - rp / a;
        if (!isFinite(e) || e < 0) e = 0;
        if (e > 0.999) e = 0.999;

        const maxR = ra;
        const maxRPx = maxR * scale;
        if (maxRPx < 1 || maxRPx > SAFE_ORBIT_RADIUS_PX) return;

        let px = oe.periX - oe.bodyX;
        let py = oe.periY - oe.bodyY;
        let plen = Math.hypot(px, py);
        if (plen < 1e-6) return;

        const pHatX = px / plen;
        const pHatY = py / plen;
        const qHatX = -pHatY;
        const qHatY =  pHatX;

        ctx.save();
        ctx.strokeStyle = "rgba(80,180,255,0.9)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 2]);

        ctx.beginPath();
        let started = false;
        let prevOnScreen = false;

        const steps = 240;
        for (let i = 0; i <= steps; i++) {
          const f = (2 * Math.PI * i) / steps;
          const r = a * (1 - e * e) / (1 + e * Math.cos(f));
          if (!isFinite(r) || r <= 0) continue;

          const cosf = Math.cos(f);
          const sinf = Math.sin(f);

          const worldX =
            oe.bodyX + r * (cosf * pHatX + sinf * qHatX);
          const worldY =
            oe.bodyY + r * (cosf * pHatY + sinf * qHatY);

          const p = worldToScreen(worldX, worldY);
          const onScreen =
            p.x >= -50 && p.x <= w + 50 &&
            p.y >= -50 && p.y <= h + 50;

          if (!onScreen) {
            prevOnScreen = false;
            continue;
          }

          if (!started) {
            ctx.moveTo(p.x, p.y);
            started = true;
          } else if (!prevOnScreen) {
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }

          prevOnScreen = true;
        }

        ctx.stroke();
        ctx.restore();
      })();

      // --- Apsis lines + markers ---------------------------------------
      if (screenWithinBounds(periScreen) || screenWithinBounds(apoScreen) || screenWithinBounds(bodyScreen)) {
        ctx.save();
        ctx.setLineDash([]);
        ctx.lineWidth = 1;

        ctx.strokeStyle = "rgba(0,255,136,0.5)";
        ctx.beginPath();
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(periScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(periScreen.x, periScreen.y);
        }
        if (screenWithinBounds(bodyScreen) && screenWithinBounds(apoScreen)) {
          ctx.moveTo(bodyScreen.x, bodyScreen.y);
          ctx.lineTo(apoScreen.x, apoScreen.y);
        }
        ctx.stroke();

        if (screenWithinBounds(periScreen)) {
          ctx.fillStyle = "#00ff88";
          ctx.beginPath();
          ctx.arc(periScreen.x, periScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#00ff88";
          ctx.fillText("Pe", periScreen.x + 6, periScreen.y - 2);
        }

        if (screenWithinBounds(apoScreen)) {
          ctx.fillStyle = "#ff66ff";
          ctx.beginPath();
          ctx.arc(apoScreen.x, apoScreen.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "11px system-ui";
          ctx.textAlign = "left";
          ctx.textBaseline = "bottom";
          ctx.fillStyle = "#ff66ff";
          ctx.fillText("Ap", apoScreen.x + 6, apoScreen.y - 2);
        }

        ctx.restore();
      }
    }

    // Rocket
    const rocket = state.rocket;
    const rocketScreen = worldToScreen(rocket.x, rocket.y);

    ctx.save();
    ctx.translate(rocketScreen.x, rocketScreen.y);
    ctx.rotate(-rocket.angle + Math.PI / 2);

    const bodyWidth = 6;
    const bodyHeight = 20;

    const stageIndex = state.currentStageIndex;
    const colors = ["#dddddd", "#ffcc66", "#99ccff"];
    const bodyColor = colors[Math.min(colors.length - 1, stageIndex + 1)];

    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.7);
    ctx.lineTo(bodyWidth / 2, bodyHeight * 0.3);
    ctx.lineTo(0, bodyHeight * 0.5);
    ctx.lineTo(-bodyWidth / 2, bodyHeight * 0.3);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(0, -bodyHeight * 0.9);
    ctx.lineTo(bodyWidth / 2, -bodyHeight * 0.7);
    ctx.lineTo(-bodyWidth / 2, -bodyHeight * 0.7);
    ctx.closePath();
    ctx.fill();

    if (rocket.thrusting && !state.crashed && !state.landed) {
      ctx.fillStyle = "#ff9933";
      ctx.beginPath();
      ctx.moveTo(0, bodyHeight * 0.5);
      ctx.lineTo(bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.lineTo(-bodyWidth * 0.7, bodyHeight * 0.9 + Math.random() * 4);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // HUD
    const primary = state.primaryBody || getPrimaryBody(rocket.x, rocket.y);
    const dxp = rocket.x - primary.x;
    const dyp = rocket.y - primary.y;
    const rPrimary = Math.hypot(dxp, dyp);
    const alt = rPrimary - primary.radius;
    const speed = Math.hypot(rocket.vx, rocket.vy);
    const radialVel = (dxp * rocket.vx + dyp * rocket.vy) / rPrimary;

    const stage = currentStage();
    const stageName = stage ? stage.name : "None";
    const fuel = stage ? stage.fuel : 0;
    const maxFuel = stage ? stage.maxFuel : 1;
    const fuelPct = Math.max(0, Math.min(100, (fuel / maxFuel) * 100));

    let orbitStatus;
    if (state.orbitEscaping) {
      orbitStatus = state.escaped ? "Escaped system" : "Escaping " + primary.name;
    } else if (state.orbitStable) {
      orbitStatus = "Stable orbit around " + primary.name;
    } else if (state.orbitBound) {
      orbitStatus = "Bound to " + primary.name + " (reentry)";
    } else {
      orbitStatus = "Suborbital / transitioning";
    }

    const periapsisText =
      state.lastPeriapsis != null
        ? (state.lastPeriapsis >= 0
            ? state.lastPeriapsis.toFixed(1) + " km"
            : "surface")
        : "unknown";

    const apoapsisText =
      state.orbitElements && state.orbitBound
        ? (state.orbitElements.apoRadius - primary.radius).toFixed(1) + " km"
        : "unknown";

    const camModeText = cameraFollow ? "Follow ship" : "Free";

    overlay.textContent =
      "BODY: " + primary.name + "\n" +
      "ALT: " + alt.toFixed(1) + " km\n" +
      "SPEED: " + speed.toFixed(2) + " km/s\n" +
      "VERT SPD: " + radialVel.toFixed(2) + " km/s (" + (radialVel >= 0 ? "↑" : "↓") + ")\n" +
      "STAGE: " + stageName + " (" + fuelPct.toFixed(0) + "% fuel)\n" +
      "ORBIT: " + orbitStatus + "\n" +
      "Periapsis: " + periapsisText + "\n" +
      "Apoapsis: " + apoapsisText + "\n" +
      "WARP: " + timeScale.toFixed(2) + "x\n" +
      "ZOOM: " + cameraZoom.toFixed(2) + "x\n" +
      "CAM: " + camModeText + "\n";

    if (transferPlan) {
      const origin = BODIES[transferPlan.originIndex];
      const dest = BODIES[transferPlan.destIndex];

      const currentPhase = normalizeAngle(dest.angle - origin.angle);
      const phaseErrorRad = smallestAngleDiff(transferPlan.phaseTarget, currentPhase);
      const phaseErrorDeg = phaseErrorRad * 180 / Math.PI;

      const relOmega = transferPlan.omegaDest - transferPlan.omegaOrigin;
      let timeToWindow = null;
      if (Math.abs(relOmega) > 1e-8) {
        let tRaw = phaseErrorRad / relOmega;
        const synodicPeriod = 2 * Math.PI / Math.abs(relOmega);
        tRaw = ((tRaw % synodicPeriod) + synodicPeriod) % synodicPeriod;
        timeToWindow = tRaw;
      }

      overlay.textContent +=
        "\nTRANSFER: " + origin.name + " → " + dest.name + "\n" +
        "Phase error: " + phaseErrorDeg.toFixed(1) + "°\n" +
        (timeToWindow != null
           ? "Time to window: " + (timeToWindow / 60).toFixed(1) + " min\n"
           : "") +
        "Δv1 (depart): " + transferPlan.deltaV1.toFixed(3) + " km/s\n" +
        "Δv2 (circularize): " + transferPlan.deltaV2.toFixed(3) + " km/s\n";
    }

    overlay.textContent += "\n" + state.message;
  }

  // --- Main loop ---------------------------------------------------------
  let lastTime = performance.now();
  function loop(now) {
    const realDt = (now - lastTime) / 1000;
    lastTime = now;

    let dtRemaining = Math.max(0, realDt * timeScale);
    const maxStep = 0.05;
    const maxStepsPerFrame = 100;
    let steps = 0;

    while (dtRemaining > 0 && steps < maxStepsPerFrame) {
      const step = Math.min(maxStep, dtRemaining);
      update(step);
      dtRemaining -= step;
      steps++;
    }

    updatePredictedPath();
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
